// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goby_msgs.proto

#ifndef PROTOBUF_INCLUDED_goby_5fmsgs_2eproto
#define PROTOBUF_INCLUDED_goby_5fmsgs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dccl/option_extensions.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goby_5fmsgs_2eproto 

namespace protobuf_goby_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goby_5fmsgs_2eproto
class ControllerInfo;
class ControllerInfoDefaultTypeInternal;
extern ControllerInfoDefaultTypeInternal _ControllerInfo_default_instance_;
class DirectControl;
class DirectControlDefaultTypeInternal;
extern DirectControlDefaultTypeInternal _DirectControl_default_instance_;
class ExecuteWaypoints;
class ExecuteWaypointsDefaultTypeInternal;
extern ExecuteWaypointsDefaultTypeInternal _ExecuteWaypoints_default_instance_;
class Health;
class HealthDefaultTypeInternal;
extern HealthDefaultTypeInternal _Health_default_instance_;
class MultiWaypointGPS;
class MultiWaypointGPSDefaultTypeInternal;
extern MultiWaypointGPSDefaultTypeInternal _MultiWaypointGPS_default_instance_;
class MultiWaypointXYZ;
class MultiWaypointXYZDefaultTypeInternal;
extern MultiWaypointXYZDefaultTypeInternal _MultiWaypointXYZ_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class RelativePose;
class RelativePoseDefaultTypeInternal;
extern RelativePoseDefaultTypeInternal _RelativePose_default_instance_;
class SingleWaypoint;
class SingleWaypointDefaultTypeInternal;
extern SingleWaypointDefaultTypeInternal _SingleWaypoint_default_instance_;
class StateInfo;
class StateInfoDefaultTypeInternal;
extern StateInfoDefaultTypeInternal _StateInfo_default_instance_;
namespace google {
namespace protobuf {
template<> ::ControllerInfo* Arena::CreateMaybeMessage<::ControllerInfo>(Arena*);
template<> ::DirectControl* Arena::CreateMaybeMessage<::DirectControl>(Arena*);
template<> ::ExecuteWaypoints* Arena::CreateMaybeMessage<::ExecuteWaypoints>(Arena*);
template<> ::Health* Arena::CreateMaybeMessage<::Health>(Arena*);
template<> ::MultiWaypointGPS* Arena::CreateMaybeMessage<::MultiWaypointGPS>(Arena*);
template<> ::MultiWaypointXYZ* Arena::CreateMaybeMessage<::MultiWaypointXYZ>(Arena*);
template<> ::Pose* Arena::CreateMaybeMessage<::Pose>(Arena*);
template<> ::RelativePose* Arena::CreateMaybeMessage<::RelativePose>(Arena*);
template<> ::SingleWaypoint* Arena::CreateMaybeMessage<::SingleWaypoint>(Arena*);
template<> ::StateInfo* Arena::CreateMaybeMessage<::StateInfo>(Arena*);
}  // namespace protobuf
}  // namespace google

enum RelativePose_Frame {
  RelativePose_Frame_BASE_LINK = 0,
  RelativePose_Frame_ODOM = 1,
  RelativePose_Frame_WORLD = 2,
  RelativePose_Frame_USBL = 3
};
bool RelativePose_Frame_IsValid(int value);
const RelativePose_Frame RelativePose_Frame_Frame_MIN = RelativePose_Frame_BASE_LINK;
const RelativePose_Frame RelativePose_Frame_Frame_MAX = RelativePose_Frame_USBL;
const int RelativePose_Frame_Frame_ARRAYSIZE = RelativePose_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativePose_Frame_descriptor();
inline const ::std::string& RelativePose_Frame_Name(RelativePose_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativePose_Frame_descriptor(), value);
}
inline bool RelativePose_Frame_Parse(
    const ::std::string& name, RelativePose_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativePose_Frame>(
    RelativePose_Frame_descriptor(), name, value);
}
enum DirectControl_Frame {
  DirectControl_Frame_BASE_LINK = 0,
  DirectControl_Frame_ODOM = 1,
  DirectControl_Frame_WORLD = 2,
  DirectControl_Frame_USBL = 3
};
bool DirectControl_Frame_IsValid(int value);
const DirectControl_Frame DirectControl_Frame_Frame_MIN = DirectControl_Frame_BASE_LINK;
const DirectControl_Frame DirectControl_Frame_Frame_MAX = DirectControl_Frame_USBL;
const int DirectControl_Frame_Frame_ARRAYSIZE = DirectControl_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectControl_Frame_descriptor();
inline const ::std::string& DirectControl_Frame_Name(DirectControl_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectControl_Frame_descriptor(), value);
}
inline bool DirectControl_Frame_Parse(
    const ::std::string& name, DirectControl_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectControl_Frame>(
    DirectControl_Frame_descriptor(), name, value);
}
enum StateInfo_State {
  StateInfo_State_KILL = 0,
  StateInfo_State_START = 1,
  StateInfo_State_SURVEY_LOCAL = 2,
  StateInfo_State_SURVEY_GLOBAL = 3,
  StateInfo_State_DIRECT_CONTROL = 4,
  StateInfo_State_SURVEY_3D = 5
};
bool StateInfo_State_IsValid(int value);
const StateInfo_State StateInfo_State_State_MIN = StateInfo_State_KILL;
const StateInfo_State StateInfo_State_State_MAX = StateInfo_State_SURVEY_3D;
const int StateInfo_State_State_ARRAYSIZE = StateInfo_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* StateInfo_State_descriptor();
inline const ::std::string& StateInfo_State_Name(StateInfo_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    StateInfo_State_descriptor(), value);
}
inline bool StateInfo_State_Parse(
    const ::std::string& name, StateInfo_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateInfo_State>(
    StateInfo_State_descriptor(), name, value);
}
enum ExecuteWaypoints_WaypointMode {
  ExecuteWaypoints_WaypointMode_APPEND = 0,
  ExecuteWaypoints_WaypointMode_UPDATE = 1
};
bool ExecuteWaypoints_WaypointMode_IsValid(int value);
const ExecuteWaypoints_WaypointMode ExecuteWaypoints_WaypointMode_WaypointMode_MIN = ExecuteWaypoints_WaypointMode_APPEND;
const ExecuteWaypoints_WaypointMode ExecuteWaypoints_WaypointMode_WaypointMode_MAX = ExecuteWaypoints_WaypointMode_UPDATE;
const int ExecuteWaypoints_WaypointMode_WaypointMode_ARRAYSIZE = ExecuteWaypoints_WaypointMode_WaypointMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteWaypoints_WaypointMode_descriptor();
inline const ::std::string& ExecuteWaypoints_WaypointMode_Name(ExecuteWaypoints_WaypointMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteWaypoints_WaypointMode_descriptor(), value);
}
inline bool ExecuteWaypoints_WaypointMode_Parse(
    const ::std::string& name, ExecuteWaypoints_WaypointMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteWaypoints_WaypointMode>(
    ExecuteWaypoints_WaypointMode_descriptor(), name, value);
}
// ===================================================================

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool cmd_resp = 2;
  bool has_cmd_resp() const;
  void clear_cmd_resp();
  static const int kCmdRespFieldNumber = 2;
  bool cmd_resp() const;
  void set_cmd_resp(bool value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional double latitude = 4 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 5 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // optional int32 local_x = 6 [(.dccl.field) = {
  bool has_local_x() const;
  void clear_local_x();
  static const int kLocalXFieldNumber = 6;
  ::google::protobuf::int32 local_x() const;
  void set_local_x(::google::protobuf::int32 value);

  // optional int32 local_y = 7 [(.dccl.field) = {
  bool has_local_y() const;
  void clear_local_y();
  static const int kLocalYFieldNumber = 7;
  ::google::protobuf::int32 local_y() const;
  void set_local_y(::google::protobuf::int32 value);

  // optional int32 local_z = 8 [(.dccl.field) = {
  bool has_local_z() const;
  void clear_local_z();
  static const int kLocalZFieldNumber = 8;
  ::google::protobuf::int32 local_z() const;
  void set_local_z(::google::protobuf::int32 value);

  // optional float x_rot = 9 [(.dccl.field) = {
  bool has_x_rot() const;
  void clear_x_rot();
  static const int kXRotFieldNumber = 9;
  float x_rot() const;
  void set_x_rot(float value);

  // optional float y_rot = 10 [(.dccl.field) = {
  bool has_y_rot() const;
  void clear_y_rot();
  static const int kYRotFieldNumber = 10;
  float y_rot() const;
  void set_y_rot(float value);

  // optional float z_rot = 11 [(.dccl.field) = {
  bool has_z_rot() const;
  void clear_z_rot();
  static const int kZRotFieldNumber = 11;
  float z_rot() const;
  void set_z_rot(float value);

  // optional float w_rot = 12 [(.dccl.field) = {
  bool has_w_rot() const;
  void clear_w_rot();
  static const int kWRotFieldNumber = 12;
  float w_rot() const;
  void set_w_rot(float value);

  // @@protoc_insertion_point(class_scope:Pose)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_cmd_resp();
  void clear_has_cmd_resp();
  void set_has_time();
  void clear_has_time();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_local_x();
  void clear_has_local_x();
  void set_has_local_y();
  void clear_has_local_y();
  void set_has_local_z();
  void clear_has_local_z();
  void set_has_x_rot();
  void clear_has_x_rot();
  void set_has_y_rot();
  void clear_has_y_rot();
  void set_has_z_rot();
  void clear_has_z_rot();
  void set_has_w_rot();
  void clear_has_w_rot();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 destination_;
  bool cmd_resp_;
  double time_;
  double latitude_;
  double longitude_;
  ::google::protobuf::int32 local_x_;
  ::google::protobuf::int32 local_y_;
  ::google::protobuf::int32 local_z_;
  float x_rot_;
  float y_rot_;
  float z_rot_;
  float w_rot_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Health : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Health) */ {
 public:
  Health();
  virtual ~Health();

  Health(const Health& from);

  inline Health& operator=(const Health& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Health(Health&& from) noexcept
    : Health() {
    *this = ::std::move(from);
  }

  inline Health& operator=(Health&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Health& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Health* internal_default_instance() {
    return reinterpret_cast<const Health*>(
               &_Health_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Health* other);
  friend void swap(Health& a, Health& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Health* New() const final {
    return CreateMaybeMessage<Health>(NULL);
  }

  Health* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Health>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Health& from);
  void MergeFrom(const Health& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Health* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional bool cmd_resp = 2;
  bool has_cmd_resp() const;
  void clear_cmd_resp();
  static const int kCmdRespFieldNumber = 2;
  bool cmd_resp() const;
  void set_cmd_resp(bool value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional float batt_volt = 4 [(.dccl.field) = {
  bool has_batt_volt() const;
  void clear_batt_volt();
  static const int kBattVoltFieldNumber = 4;
  float batt_volt() const;
  void set_batt_volt(float value);

  // optional float current = 5 [(.dccl.field) = {
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 5;
  float current() const;
  void set_current(float value);

  // @@protoc_insertion_point(class_scope:Health)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_cmd_resp();
  void clear_has_cmd_resp();
  void set_has_time();
  void clear_has_time();
  void set_has_batt_volt();
  void clear_has_batt_volt();
  void set_has_current();
  void clear_has_current();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 destination_;
  bool cmd_resp_;
  double time_;
  float batt_volt_;
  float current_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RelativePose) */ {
 public:
  RelativePose();
  virtual ~RelativePose();

  RelativePose(const RelativePose& from);

  inline RelativePose& operator=(const RelativePose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePose(RelativePose&& from) noexcept
    : RelativePose() {
    *this = ::std::move(from);
  }

  inline RelativePose& operator=(RelativePose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePose* internal_default_instance() {
    return reinterpret_cast<const RelativePose*>(
               &_RelativePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RelativePose* other);
  friend void swap(RelativePose& a, RelativePose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePose* New() const final {
    return CreateMaybeMessage<RelativePose>(NULL);
  }

  RelativePose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePose& from);
  void MergeFrom(const RelativePose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelativePose_Frame Frame;
  static const Frame BASE_LINK =
    RelativePose_Frame_BASE_LINK;
  static const Frame ODOM =
    RelativePose_Frame_ODOM;
  static const Frame WORLD =
    RelativePose_Frame_WORLD;
  static const Frame USBL =
    RelativePose_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return RelativePose_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    RelativePose_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    RelativePose_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    RelativePose_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return RelativePose_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return RelativePose_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return RelativePose_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool cmd_resp = 2;
  bool has_cmd_resp() const;
  void clear_cmd_resp();
  static const int kCmdRespFieldNumber = 2;
  bool cmd_resp() const;
  void set_cmd_resp(bool value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional .RelativePose.Frame parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  ::RelativePose_Frame parent() const;
  void set_parent(::RelativePose_Frame value);

  // optional .RelativePose.Frame child = 5;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::RelativePose_Frame child() const;
  void set_child(::RelativePose_Frame value);

  // optional float local_x = 6 [(.dccl.field) = {
  bool has_local_x() const;
  void clear_local_x();
  static const int kLocalXFieldNumber = 6;
  float local_x() const;
  void set_local_x(float value);

  // optional float local_y = 7 [(.dccl.field) = {
  bool has_local_y() const;
  void clear_local_y();
  static const int kLocalYFieldNumber = 7;
  float local_y() const;
  void set_local_y(float value);

  // optional float local_z = 8 [(.dccl.field) = {
  bool has_local_z() const;
  void clear_local_z();
  static const int kLocalZFieldNumber = 8;
  float local_z() const;
  void set_local_z(float value);

  // optional float x_rot = 9 [(.dccl.field) = {
  bool has_x_rot() const;
  void clear_x_rot();
  static const int kXRotFieldNumber = 9;
  float x_rot() const;
  void set_x_rot(float value);

  // optional int32 y_rot = 10 [(.dccl.field) = {
  bool has_y_rot() const;
  void clear_y_rot();
  static const int kYRotFieldNumber = 10;
  ::google::protobuf::int32 y_rot() const;
  void set_y_rot(::google::protobuf::int32 value);

  // optional int32 z_rot = 11 [(.dccl.field) = {
  bool has_z_rot() const;
  void clear_z_rot();
  static const int kZRotFieldNumber = 11;
  ::google::protobuf::int32 z_rot() const;
  void set_z_rot(::google::protobuf::int32 value);

  // optional int32 w_rot = 12 [(.dccl.field) = {
  bool has_w_rot() const;
  void clear_w_rot();
  static const int kWRotFieldNumber = 12;
  ::google::protobuf::int32 w_rot() const;
  void set_w_rot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RelativePose)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_cmd_resp();
  void clear_has_cmd_resp();
  void set_has_time();
  void clear_has_time();
  void set_has_parent();
  void clear_has_parent();
  void set_has_child();
  void clear_has_child();
  void set_has_local_x();
  void clear_has_local_x();
  void set_has_local_y();
  void clear_has_local_y();
  void set_has_local_z();
  void clear_has_local_z();
  void set_has_x_rot();
  void clear_has_x_rot();
  void set_has_y_rot();
  void clear_has_y_rot();
  void set_has_z_rot();
  void clear_has_z_rot();
  void set_has_w_rot();
  void clear_has_w_rot();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 destination_;
  bool cmd_resp_;
  double time_;
  int parent_;
  int child_;
  float local_x_;
  float local_y_;
  float local_z_;
  float x_rot_;
  ::google::protobuf::int32 y_rot_;
  ::google::protobuf::int32 z_rot_;
  ::google::protobuf::int32 w_rot_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControllerInfo) */ {
 public:
  ControllerInfo();
  virtual ~ControllerInfo();

  ControllerInfo(const ControllerInfo& from);

  inline ControllerInfo& operator=(const ControllerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerInfo(ControllerInfo&& from) noexcept
    : ControllerInfo() {
    *this = ::std::move(from);
  }

  inline ControllerInfo& operator=(ControllerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerInfo* internal_default_instance() {
    return reinterpret_cast<const ControllerInfo*>(
               &_ControllerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ControllerInfo* other);
  friend void swap(ControllerInfo& a, ControllerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerInfo* New() const final {
    return CreateMaybeMessage<ControllerInfo>(NULL);
  }

  ControllerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControllerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControllerInfo& from);
  void MergeFrom(const ControllerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool setget = 3;
  bool has_setget() const;
  void clear_setget();
  static const int kSetgetFieldNumber = 3;
  bool setget() const;
  void set_setget(bool value);

  // optional bool state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:ControllerInfo)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_setget();
  void clear_has_setget();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  bool setget_;
  bool state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DirectControl) */ {
 public:
  DirectControl();
  virtual ~DirectControl();

  DirectControl(const DirectControl& from);

  inline DirectControl& operator=(const DirectControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectControl(DirectControl&& from) noexcept
    : DirectControl() {
    *this = ::std::move(from);
  }

  inline DirectControl& operator=(DirectControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectControl* internal_default_instance() {
    return reinterpret_cast<const DirectControl*>(
               &_DirectControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DirectControl* other);
  friend void swap(DirectControl& a, DirectControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectControl* New() const final {
    return CreateMaybeMessage<DirectControl>(NULL);
  }

  DirectControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectControl& from);
  void MergeFrom(const DirectControl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DirectControl_Frame Frame;
  static const Frame BASE_LINK =
    DirectControl_Frame_BASE_LINK;
  static const Frame ODOM =
    DirectControl_Frame_ODOM;
  static const Frame WORLD =
    DirectControl_Frame_WORLD;
  static const Frame USBL =
    DirectControl_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return DirectControl_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    DirectControl_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    DirectControl_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    DirectControl_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return DirectControl_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return DirectControl_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return DirectControl_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool setget = 3;
  bool has_setget() const;
  void clear_setget();
  static const int kSetgetFieldNumber = 3;
  bool setget() const;
  void set_setget(bool value);

  // optional .DirectControl.Frame frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::DirectControl_Frame frame() const;
  void set_frame(::DirectControl_Frame value);

  // optional float set_x = 6 [(.dccl.field) = {
  bool has_set_x() const;
  void clear_set_x();
  static const int kSetXFieldNumber = 6;
  float set_x() const;
  void set_set_x(float value);

  // optional float set_y = 7 [(.dccl.field) = {
  bool has_set_y() const;
  void clear_set_y();
  static const int kSetYFieldNumber = 7;
  float set_y() const;
  void set_set_y(float value);

  // optional float set_z = 8 [(.dccl.field) = {
  bool has_set_z() const;
  void clear_set_z();
  static const int kSetZFieldNumber = 8;
  float set_z() const;
  void set_set_z(float value);

  // optional float set_roll = 9 [(.dccl.field) = {
  bool has_set_roll() const;
  void clear_set_roll();
  static const int kSetRollFieldNumber = 9;
  float set_roll() const;
  void set_set_roll(float value);

  // optional float set_pitch = 10 [(.dccl.field) = {
  bool has_set_pitch() const;
  void clear_set_pitch();
  static const int kSetPitchFieldNumber = 10;
  float set_pitch() const;
  void set_set_pitch(float value);

  // optional float set_yaw = 11 [(.dccl.field) = {
  bool has_set_yaw() const;
  void clear_set_yaw();
  static const int kSetYawFieldNumber = 11;
  float set_yaw() const;
  void set_set_yaw(float value);

  // optional float set_u = 12 [(.dccl.field) = {
  bool has_set_u() const;
  void clear_set_u();
  static const int kSetUFieldNumber = 12;
  float set_u() const;
  void set_set_u(float value);

  // optional float set_v = 13 [(.dccl.field) = {
  bool has_set_v() const;
  void clear_set_v();
  static const int kSetVFieldNumber = 13;
  float set_v() const;
  void set_set_v(float value);

  // optional float set_w = 14 [(.dccl.field) = {
  bool has_set_w() const;
  void clear_set_w();
  static const int kSetWFieldNumber = 14;
  float set_w() const;
  void set_set_w(float value);

  // optional float set_p = 15 [(.dccl.field) = {
  bool has_set_p() const;
  void clear_set_p();
  static const int kSetPFieldNumber = 15;
  float set_p() const;
  void set_set_p(float value);

  // optional float set_q = 16 [(.dccl.field) = {
  bool has_set_q() const;
  void clear_set_q();
  static const int kSetQFieldNumber = 16;
  float set_q() const;
  void set_set_q(float value);

  // optional float set_r = 17 [(.dccl.field) = {
  bool has_set_r() const;
  void clear_set_r();
  static const int kSetRFieldNumber = 17;
  float set_r() const;
  void set_set_r(float value);

  // @@protoc_insertion_point(class_scope:DirectControl)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_setget();
  void clear_has_setget();
  void set_has_frame();
  void clear_has_frame();
  void set_has_set_x();
  void clear_has_set_x();
  void set_has_set_y();
  void clear_has_set_y();
  void set_has_set_z();
  void clear_has_set_z();
  void set_has_set_roll();
  void clear_has_set_roll();
  void set_has_set_pitch();
  void clear_has_set_pitch();
  void set_has_set_yaw();
  void clear_has_set_yaw();
  void set_has_set_u();
  void clear_has_set_u();
  void set_has_set_v();
  void clear_has_set_v();
  void set_has_set_w();
  void clear_has_set_w();
  void set_has_set_p();
  void clear_has_set_p();
  void set_has_set_q();
  void clear_has_set_q();
  void set_has_set_r();
  void clear_has_set_r();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  bool setget_;
  int frame_;
  float set_x_;
  float set_y_;
  float set_z_;
  float set_roll_;
  float set_pitch_;
  float set_yaw_;
  float set_u_;
  float set_v_;
  float set_w_;
  float set_p_;
  float set_q_;
  float set_r_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StateInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StateInfo) */ {
 public:
  StateInfo();
  virtual ~StateInfo();

  StateInfo(const StateInfo& from);

  inline StateInfo& operator=(const StateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StateInfo(StateInfo&& from) noexcept
    : StateInfo() {
    *this = ::std::move(from);
  }

  inline StateInfo& operator=(StateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateInfo* internal_default_instance() {
    return reinterpret_cast<const StateInfo*>(
               &_StateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(StateInfo* other);
  friend void swap(StateInfo& a, StateInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StateInfo* New() const final {
    return CreateMaybeMessage<StateInfo>(NULL);
  }

  StateInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StateInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StateInfo& from);
  void MergeFrom(const StateInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StateInfo_State State;
  static const State KILL =
    StateInfo_State_KILL;
  static const State START =
    StateInfo_State_START;
  static const State SURVEY_LOCAL =
    StateInfo_State_SURVEY_LOCAL;
  static const State SURVEY_GLOBAL =
    StateInfo_State_SURVEY_GLOBAL;
  static const State DIRECT_CONTROL =
    StateInfo_State_DIRECT_CONTROL;
  static const State SURVEY_3D =
    StateInfo_State_SURVEY_3D;
  static inline bool State_IsValid(int value) {
    return StateInfo_State_IsValid(value);
  }
  static const State State_MIN =
    StateInfo_State_State_MIN;
  static const State State_MAX =
    StateInfo_State_State_MAX;
  static const int State_ARRAYSIZE =
    StateInfo_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return StateInfo_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return StateInfo_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return StateInfo_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool setget = 3;
  bool has_setget() const;
  void clear_setget();
  static const int kSetgetFieldNumber = 3;
  bool setget() const;
  void set_setget(bool value);

  // optional .StateInfo.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::StateInfo_State state() const;
  void set_state(::StateInfo_State value);

  // @@protoc_insertion_point(class_scope:StateInfo)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_setget();
  void clear_has_setget();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  bool setget_;
  int state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SingleWaypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SingleWaypoint) */ {
 public:
  SingleWaypoint();
  virtual ~SingleWaypoint();

  SingleWaypoint(const SingleWaypoint& from);

  inline SingleWaypoint& operator=(const SingleWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SingleWaypoint(SingleWaypoint&& from) noexcept
    : SingleWaypoint() {
    *this = ::std::move(from);
  }

  inline SingleWaypoint& operator=(SingleWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleWaypoint* internal_default_instance() {
    return reinterpret_cast<const SingleWaypoint*>(
               &_SingleWaypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SingleWaypoint* other);
  friend void swap(SingleWaypoint& a, SingleWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SingleWaypoint* New() const final {
    return CreateMaybeMessage<SingleWaypoint>(NULL);
  }

  SingleWaypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SingleWaypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SingleWaypoint& from);
  void MergeFrom(const SingleWaypoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool setget = 3;
  bool has_setget() const;
  void clear_setget();
  static const int kSetgetFieldNumber = 3;
  bool setget() const;
  void set_setget(bool value);

  // optional double latitude = 4 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 5 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // optional int32 local_x = 6 [(.dccl.field) = {
  bool has_local_x() const;
  void clear_local_x();
  static const int kLocalXFieldNumber = 6;
  ::google::protobuf::int32 local_x() const;
  void set_local_x(::google::protobuf::int32 value);

  // optional int32 local_y = 7 [(.dccl.field) = {
  bool has_local_y() const;
  void clear_local_y();
  static const int kLocalYFieldNumber = 7;
  ::google::protobuf::int32 local_y() const;
  void set_local_y(::google::protobuf::int32 value);

  // required int32 depth = 8 [(.dccl.field) = {
  bool has_depth() const;
  void clear_depth();
  static const int kDepthFieldNumber = 8;
  ::google::protobuf::int32 depth() const;
  void set_depth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SingleWaypoint)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_setget();
  void clear_has_setget();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_local_x();
  void clear_has_local_x();
  void set_has_local_y();
  void clear_has_local_y();
  void set_has_depth();
  void clear_has_depth();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  bool setget_;
  double latitude_;
  double longitude_;
  ::google::protobuf::int32 local_x_;
  ::google::protobuf::int32 local_y_;
  ::google::protobuf::int32 depth_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointGPS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointGPS) */ {
 public:
  MultiWaypointGPS();
  virtual ~MultiWaypointGPS();

  MultiWaypointGPS(const MultiWaypointGPS& from);

  inline MultiWaypointGPS& operator=(const MultiWaypointGPS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointGPS(MultiWaypointGPS&& from) noexcept
    : MultiWaypointGPS() {
    *this = ::std::move(from);
  }

  inline MultiWaypointGPS& operator=(MultiWaypointGPS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointGPS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointGPS* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointGPS*>(
               &_MultiWaypointGPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MultiWaypointGPS* other);
  friend void swap(MultiWaypointGPS& a, MultiWaypointGPS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointGPS* New() const final {
    return CreateMaybeMessage<MultiWaypointGPS>(NULL);
  }

  MultiWaypointGPS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointGPS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointGPS& from);
  void MergeFrom(const MultiWaypointGPS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointGPS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required int32 wpt_num = 3 [(.dccl.field) = {
  bool has_wpt_num() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 3;
  ::google::protobuf::int32 wpt_num() const;
  void set_wpt_num(::google::protobuf::int32 value);

  // optional double latitude_1 = 4 [(.dccl.field) = {
  bool has_latitude_1() const;
  void clear_latitude_1();
  static const int kLatitude1FieldNumber = 4;
  double latitude_1() const;
  void set_latitude_1(double value);

  // optional double longitude_1 = 5 [(.dccl.field) = {
  bool has_longitude_1() const;
  void clear_longitude_1();
  static const int kLongitude1FieldNumber = 5;
  double longitude_1() const;
  void set_longitude_1(double value);

  // optional double latitude_2 = 7 [(.dccl.field) = {
  bool has_latitude_2() const;
  void clear_latitude_2();
  static const int kLatitude2FieldNumber = 7;
  double latitude_2() const;
  void set_latitude_2(double value);

  // optional int32 depth_1 = 6 [(.dccl.field) = {
  bool has_depth_1() const;
  void clear_depth_1();
  static const int kDepth1FieldNumber = 6;
  ::google::protobuf::int32 depth_1() const;
  void set_depth_1(::google::protobuf::int32 value);

  // optional int32 depth_2 = 9 [(.dccl.field) = {
  bool has_depth_2() const;
  void clear_depth_2();
  static const int kDepth2FieldNumber = 9;
  ::google::protobuf::int32 depth_2() const;
  void set_depth_2(::google::protobuf::int32 value);

  // optional double longitude_2 = 8 [(.dccl.field) = {
  bool has_longitude_2() const;
  void clear_longitude_2();
  static const int kLongitude2FieldNumber = 8;
  double longitude_2() const;
  void set_longitude_2(double value);

  // optional double latitude_3 = 10 [(.dccl.field) = {
  bool has_latitude_3() const;
  void clear_latitude_3();
  static const int kLatitude3FieldNumber = 10;
  double latitude_3() const;
  void set_latitude_3(double value);

  // optional double longitude_3 = 11 [(.dccl.field) = {
  bool has_longitude_3() const;
  void clear_longitude_3();
  static const int kLongitude3FieldNumber = 11;
  double longitude_3() const;
  void set_longitude_3(double value);

  // optional int32 depth_3 = 12 [(.dccl.field) = {
  bool has_depth_3() const;
  void clear_depth_3();
  static const int kDepth3FieldNumber = 12;
  ::google::protobuf::int32 depth_3() const;
  void set_depth_3(::google::protobuf::int32 value);

  // required bool end = 13;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 13;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointGPS)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_wpt_num();
  void clear_has_wpt_num();
  void set_has_latitude_1();
  void clear_has_latitude_1();
  void set_has_longitude_1();
  void clear_has_longitude_1();
  void set_has_depth_1();
  void clear_has_depth_1();
  void set_has_latitude_2();
  void clear_has_latitude_2();
  void set_has_longitude_2();
  void clear_has_longitude_2();
  void set_has_depth_2();
  void clear_has_depth_2();
  void set_has_latitude_3();
  void clear_has_latitude_3();
  void set_has_longitude_3();
  void clear_has_longitude_3();
  void set_has_depth_3();
  void clear_has_depth_3();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  ::google::protobuf::int32 wpt_num_;
  double latitude_1_;
  double longitude_1_;
  double latitude_2_;
  ::google::protobuf::int32 depth_1_;
  ::google::protobuf::int32 depth_2_;
  double longitude_2_;
  double latitude_3_;
  double longitude_3_;
  ::google::protobuf::int32 depth_3_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointXYZ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointXYZ) */ {
 public:
  MultiWaypointXYZ();
  virtual ~MultiWaypointXYZ();

  MultiWaypointXYZ(const MultiWaypointXYZ& from);

  inline MultiWaypointXYZ& operator=(const MultiWaypointXYZ& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointXYZ(MultiWaypointXYZ&& from) noexcept
    : MultiWaypointXYZ() {
    *this = ::std::move(from);
  }

  inline MultiWaypointXYZ& operator=(MultiWaypointXYZ&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointXYZ& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointXYZ* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointXYZ*>(
               &_MultiWaypointXYZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MultiWaypointXYZ* other);
  friend void swap(MultiWaypointXYZ& a, MultiWaypointXYZ& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointXYZ* New() const final {
    return CreateMaybeMessage<MultiWaypointXYZ>(NULL);
  }

  MultiWaypointXYZ* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointXYZ>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointXYZ& from);
  void MergeFrom(const MultiWaypointXYZ& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointXYZ* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required int32 wpt_num = 3 [(.dccl.field) = {
  bool has_wpt_num() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 3;
  ::google::protobuf::int32 wpt_num() const;
  void set_wpt_num(::google::protobuf::int32 value);

  // optional int32 x_1 = 4 [(.dccl.field) = {
  bool has_x_1() const;
  void clear_x_1();
  static const int kX1FieldNumber = 4;
  ::google::protobuf::int32 x_1() const;
  void set_x_1(::google::protobuf::int32 value);

  // optional int32 y_1 = 5 [(.dccl.field) = {
  bool has_y_1() const;
  void clear_y_1();
  static const int kY1FieldNumber = 5;
  ::google::protobuf::int32 y_1() const;
  void set_y_1(::google::protobuf::int32 value);

  // optional int32 depth_1 = 6 [(.dccl.field) = {
  bool has_depth_1() const;
  void clear_depth_1();
  static const int kDepth1FieldNumber = 6;
  ::google::protobuf::int32 depth_1() const;
  void set_depth_1(::google::protobuf::int32 value);

  // optional int32 x_2 = 7 [(.dccl.field) = {
  bool has_x_2() const;
  void clear_x_2();
  static const int kX2FieldNumber = 7;
  ::google::protobuf::int32 x_2() const;
  void set_x_2(::google::protobuf::int32 value);

  // optional int32 y_2 = 8 [(.dccl.field) = {
  bool has_y_2() const;
  void clear_y_2();
  static const int kY2FieldNumber = 8;
  ::google::protobuf::int32 y_2() const;
  void set_y_2(::google::protobuf::int32 value);

  // optional int32 depth_2 = 9 [(.dccl.field) = {
  bool has_depth_2() const;
  void clear_depth_2();
  static const int kDepth2FieldNumber = 9;
  ::google::protobuf::int32 depth_2() const;
  void set_depth_2(::google::protobuf::int32 value);

  // optional int32 x_3 = 10 [(.dccl.field) = {
  bool has_x_3() const;
  void clear_x_3();
  static const int kX3FieldNumber = 10;
  ::google::protobuf::int32 x_3() const;
  void set_x_3(::google::protobuf::int32 value);

  // optional int32 y_3 = 11 [(.dccl.field) = {
  bool has_y_3() const;
  void clear_y_3();
  static const int kY3FieldNumber = 11;
  ::google::protobuf::int32 y_3() const;
  void set_y_3(::google::protobuf::int32 value);

  // optional int32 depth_3 = 12 [(.dccl.field) = {
  bool has_depth_3() const;
  void clear_depth_3();
  static const int kDepth3FieldNumber = 12;
  ::google::protobuf::int32 depth_3() const;
  void set_depth_3(::google::protobuf::int32 value);

  // required bool end = 13;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 13;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointXYZ)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_wpt_num();
  void clear_has_wpt_num();
  void set_has_x_1();
  void clear_has_x_1();
  void set_has_y_1();
  void clear_has_y_1();
  void set_has_depth_1();
  void clear_has_depth_1();
  void set_has_x_2();
  void clear_has_x_2();
  void set_has_y_2();
  void clear_has_y_2();
  void set_has_depth_2();
  void clear_has_depth_2();
  void set_has_x_3();
  void clear_has_x_3();
  void set_has_y_3();
  void clear_has_y_3();
  void set_has_depth_3();
  void clear_has_depth_3();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  ::google::protobuf::int32 wpt_num_;
  ::google::protobuf::int32 x_1_;
  ::google::protobuf::int32 y_1_;
  ::google::protobuf::int32 depth_1_;
  ::google::protobuf::int32 x_2_;
  ::google::protobuf::int32 y_2_;
  ::google::protobuf::int32 depth_2_;
  ::google::protobuf::int32 x_3_;
  ::google::protobuf::int32 y_3_;
  ::google::protobuf::int32 depth_3_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteWaypoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExecuteWaypoints) */ {
 public:
  ExecuteWaypoints();
  virtual ~ExecuteWaypoints();

  ExecuteWaypoints(const ExecuteWaypoints& from);

  inline ExecuteWaypoints& operator=(const ExecuteWaypoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteWaypoints(ExecuteWaypoints&& from) noexcept
    : ExecuteWaypoints() {
    *this = ::std::move(from);
  }

  inline ExecuteWaypoints& operator=(ExecuteWaypoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteWaypoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteWaypoints* internal_default_instance() {
    return reinterpret_cast<const ExecuteWaypoints*>(
               &_ExecuteWaypoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ExecuteWaypoints* other);
  friend void swap(ExecuteWaypoints& a, ExecuteWaypoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteWaypoints* New() const final {
    return CreateMaybeMessage<ExecuteWaypoints>(NULL);
  }

  ExecuteWaypoints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteWaypoints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteWaypoints& from);
  void MergeFrom(const ExecuteWaypoints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteWaypoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteWaypoints_WaypointMode WaypointMode;
  static const WaypointMode APPEND =
    ExecuteWaypoints_WaypointMode_APPEND;
  static const WaypointMode UPDATE =
    ExecuteWaypoints_WaypointMode_UPDATE;
  static inline bool WaypointMode_IsValid(int value) {
    return ExecuteWaypoints_WaypointMode_IsValid(value);
  }
  static const WaypointMode WaypointMode_MIN =
    ExecuteWaypoints_WaypointMode_WaypointMode_MIN;
  static const WaypointMode WaypointMode_MAX =
    ExecuteWaypoints_WaypointMode_WaypointMode_MAX;
  static const int WaypointMode_ARRAYSIZE =
    ExecuteWaypoints_WaypointMode_WaypointMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WaypointMode_descriptor() {
    return ExecuteWaypoints_WaypointMode_descriptor();
  }
  static inline const ::std::string& WaypointMode_Name(WaypointMode value) {
    return ExecuteWaypoints_WaypointMode_Name(value);
  }
  static inline bool WaypointMode_Parse(const ::std::string& name,
      WaypointMode* value) {
    return ExecuteWaypoints_WaypointMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required double time = 2 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // required int32 destination = 1 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required bool execute = 3;
  bool has_execute() const;
  void clear_execute();
  static const int kExecuteFieldNumber = 3;
  bool execute() const;
  void set_execute(bool value);

  // required .ExecuteWaypoints.WaypointMode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::ExecuteWaypoints_WaypointMode mode() const;
  void set_mode(::ExecuteWaypoints_WaypointMode value);

  // @@protoc_insertion_point(class_scope:ExecuteWaypoints)
 private:
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_execute();
  void clear_has_execute();
  void set_has_mode();
  void clear_has_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double time_;
  ::google::protobuf::int32 destination_;
  bool execute_;
  int mode_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pose

// required int32 destination = 1 [(.dccl.field) = {
inline bool Pose::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 Pose::destination() const {
  // @@protoc_insertion_point(field_get:Pose.destination)
  return destination_;
}
inline void Pose::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:Pose.destination)
}

// required bool cmd_resp = 2;
inline bool Pose::has_cmd_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_cmd_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_cmd_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_cmd_resp() {
  cmd_resp_ = false;
  clear_has_cmd_resp();
}
inline bool Pose::cmd_resp() const {
  // @@protoc_insertion_point(field_get:Pose.cmd_resp)
  return cmd_resp_;
}
inline void Pose::set_cmd_resp(bool value) {
  set_has_cmd_resp();
  cmd_resp_ = value;
  // @@protoc_insertion_point(field_set:Pose.cmd_resp)
}

// optional double time = 3 [(.dccl.field) = {
inline bool Pose::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pose::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pose::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pose::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double Pose::time() const {
  // @@protoc_insertion_point(field_get:Pose.time)
  return time_;
}
inline void Pose::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Pose.time)
}

// optional double latitude = 4 [(.dccl.field) = {
inline bool Pose::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pose::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pose::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pose::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Pose::latitude() const {
  // @@protoc_insertion_point(field_get:Pose.latitude)
  return latitude_;
}
inline void Pose::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Pose.latitude)
}

// optional double longitude = 5 [(.dccl.field) = {
inline bool Pose::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pose::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pose::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pose::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Pose::longitude() const {
  // @@protoc_insertion_point(field_get:Pose.longitude)
  return longitude_;
}
inline void Pose::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Pose.longitude)
}

// optional int32 local_x = 6 [(.dccl.field) = {
inline bool Pose::has_local_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pose::set_has_local_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pose::clear_has_local_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pose::clear_local_x() {
  local_x_ = 0;
  clear_has_local_x();
}
inline ::google::protobuf::int32 Pose::local_x() const {
  // @@protoc_insertion_point(field_get:Pose.local_x)
  return local_x_;
}
inline void Pose::set_local_x(::google::protobuf::int32 value) {
  set_has_local_x();
  local_x_ = value;
  // @@protoc_insertion_point(field_set:Pose.local_x)
}

// optional int32 local_y = 7 [(.dccl.field) = {
inline bool Pose::has_local_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pose::set_has_local_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pose::clear_has_local_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pose::clear_local_y() {
  local_y_ = 0;
  clear_has_local_y();
}
inline ::google::protobuf::int32 Pose::local_y() const {
  // @@protoc_insertion_point(field_get:Pose.local_y)
  return local_y_;
}
inline void Pose::set_local_y(::google::protobuf::int32 value) {
  set_has_local_y();
  local_y_ = value;
  // @@protoc_insertion_point(field_set:Pose.local_y)
}

// optional int32 local_z = 8 [(.dccl.field) = {
inline bool Pose::has_local_z() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pose::set_has_local_z() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pose::clear_has_local_z() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pose::clear_local_z() {
  local_z_ = 0;
  clear_has_local_z();
}
inline ::google::protobuf::int32 Pose::local_z() const {
  // @@protoc_insertion_point(field_get:Pose.local_z)
  return local_z_;
}
inline void Pose::set_local_z(::google::protobuf::int32 value) {
  set_has_local_z();
  local_z_ = value;
  // @@protoc_insertion_point(field_set:Pose.local_z)
}

// optional float x_rot = 9 [(.dccl.field) = {
inline bool Pose::has_x_rot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pose::set_has_x_rot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pose::clear_has_x_rot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pose::clear_x_rot() {
  x_rot_ = 0;
  clear_has_x_rot();
}
inline float Pose::x_rot() const {
  // @@protoc_insertion_point(field_get:Pose.x_rot)
  return x_rot_;
}
inline void Pose::set_x_rot(float value) {
  set_has_x_rot();
  x_rot_ = value;
  // @@protoc_insertion_point(field_set:Pose.x_rot)
}

// optional float y_rot = 10 [(.dccl.field) = {
inline bool Pose::has_y_rot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Pose::set_has_y_rot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Pose::clear_has_y_rot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Pose::clear_y_rot() {
  y_rot_ = 0;
  clear_has_y_rot();
}
inline float Pose::y_rot() const {
  // @@protoc_insertion_point(field_get:Pose.y_rot)
  return y_rot_;
}
inline void Pose::set_y_rot(float value) {
  set_has_y_rot();
  y_rot_ = value;
  // @@protoc_insertion_point(field_set:Pose.y_rot)
}

// optional float z_rot = 11 [(.dccl.field) = {
inline bool Pose::has_z_rot() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Pose::set_has_z_rot() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Pose::clear_has_z_rot() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Pose::clear_z_rot() {
  z_rot_ = 0;
  clear_has_z_rot();
}
inline float Pose::z_rot() const {
  // @@protoc_insertion_point(field_get:Pose.z_rot)
  return z_rot_;
}
inline void Pose::set_z_rot(float value) {
  set_has_z_rot();
  z_rot_ = value;
  // @@protoc_insertion_point(field_set:Pose.z_rot)
}

// optional float w_rot = 12 [(.dccl.field) = {
inline bool Pose::has_w_rot() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Pose::set_has_w_rot() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Pose::clear_has_w_rot() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Pose::clear_w_rot() {
  w_rot_ = 0;
  clear_has_w_rot();
}
inline float Pose::w_rot() const {
  // @@protoc_insertion_point(field_get:Pose.w_rot)
  return w_rot_;
}
inline void Pose::set_w_rot(float value) {
  set_has_w_rot();
  w_rot_ = value;
  // @@protoc_insertion_point(field_set:Pose.w_rot)
}

// -------------------------------------------------------------------

// Health

// required int32 destination = 1 [(.dccl.field) = {
inline bool Health::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Health::set_has_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Health::clear_has_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Health::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 Health::destination() const {
  // @@protoc_insertion_point(field_get:Health.destination)
  return destination_;
}
inline void Health::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:Health.destination)
}

// optional bool cmd_resp = 2;
inline bool Health::has_cmd_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Health::set_has_cmd_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Health::clear_has_cmd_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Health::clear_cmd_resp() {
  cmd_resp_ = false;
  clear_has_cmd_resp();
}
inline bool Health::cmd_resp() const {
  // @@protoc_insertion_point(field_get:Health.cmd_resp)
  return cmd_resp_;
}
inline void Health::set_cmd_resp(bool value) {
  set_has_cmd_resp();
  cmd_resp_ = value;
  // @@protoc_insertion_point(field_set:Health.cmd_resp)
}

// optional double time = 3 [(.dccl.field) = {
inline bool Health::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Health::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Health::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Health::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double Health::time() const {
  // @@protoc_insertion_point(field_get:Health.time)
  return time_;
}
inline void Health::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Health.time)
}

// optional float batt_volt = 4 [(.dccl.field) = {
inline bool Health::has_batt_volt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Health::set_has_batt_volt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Health::clear_has_batt_volt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Health::clear_batt_volt() {
  batt_volt_ = 0;
  clear_has_batt_volt();
}
inline float Health::batt_volt() const {
  // @@protoc_insertion_point(field_get:Health.batt_volt)
  return batt_volt_;
}
inline void Health::set_batt_volt(float value) {
  set_has_batt_volt();
  batt_volt_ = value;
  // @@protoc_insertion_point(field_set:Health.batt_volt)
}

// optional float current = 5 [(.dccl.field) = {
inline bool Health::has_current() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Health::set_has_current() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Health::clear_has_current() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Health::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float Health::current() const {
  // @@protoc_insertion_point(field_get:Health.current)
  return current_;
}
inline void Health::set_current(float value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:Health.current)
}

// -------------------------------------------------------------------

// RelativePose

// required int32 destination = 1 [(.dccl.field) = {
inline bool RelativePose::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePose::set_has_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePose::clear_has_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePose::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 RelativePose::destination() const {
  // @@protoc_insertion_point(field_get:RelativePose.destination)
  return destination_;
}
inline void RelativePose::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.destination)
}

// required bool cmd_resp = 2;
inline bool RelativePose::has_cmd_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePose::set_has_cmd_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePose::clear_has_cmd_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePose::clear_cmd_resp() {
  cmd_resp_ = false;
  clear_has_cmd_resp();
}
inline bool RelativePose::cmd_resp() const {
  // @@protoc_insertion_point(field_get:RelativePose.cmd_resp)
  return cmd_resp_;
}
inline void RelativePose::set_cmd_resp(bool value) {
  set_has_cmd_resp();
  cmd_resp_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.cmd_resp)
}

// optional double time = 3 [(.dccl.field) = {
inline bool RelativePose::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePose::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePose::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePose::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double RelativePose::time() const {
  // @@protoc_insertion_point(field_get:RelativePose.time)
  return time_;
}
inline void RelativePose::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.time)
}

// optional .RelativePose.Frame parent = 4;
inline bool RelativePose::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePose::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePose::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePose::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::RelativePose_Frame RelativePose::parent() const {
  // @@protoc_insertion_point(field_get:RelativePose.parent)
  return static_cast< ::RelativePose_Frame >(parent_);
}
inline void RelativePose::set_parent(::RelativePose_Frame value) {
  assert(::RelativePose_Frame_IsValid(value));
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.parent)
}

// optional .RelativePose.Frame child = 5;
inline bool RelativePose::has_child() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePose::set_has_child() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePose::clear_has_child() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePose::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::RelativePose_Frame RelativePose::child() const {
  // @@protoc_insertion_point(field_get:RelativePose.child)
  return static_cast< ::RelativePose_Frame >(child_);
}
inline void RelativePose::set_child(::RelativePose_Frame value) {
  assert(::RelativePose_Frame_IsValid(value));
  set_has_child();
  child_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.child)
}

// optional float local_x = 6 [(.dccl.field) = {
inline bool RelativePose::has_local_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RelativePose::set_has_local_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RelativePose::clear_has_local_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RelativePose::clear_local_x() {
  local_x_ = 0;
  clear_has_local_x();
}
inline float RelativePose::local_x() const {
  // @@protoc_insertion_point(field_get:RelativePose.local_x)
  return local_x_;
}
inline void RelativePose::set_local_x(float value) {
  set_has_local_x();
  local_x_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.local_x)
}

// optional float local_y = 7 [(.dccl.field) = {
inline bool RelativePose::has_local_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RelativePose::set_has_local_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RelativePose::clear_has_local_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RelativePose::clear_local_y() {
  local_y_ = 0;
  clear_has_local_y();
}
inline float RelativePose::local_y() const {
  // @@protoc_insertion_point(field_get:RelativePose.local_y)
  return local_y_;
}
inline void RelativePose::set_local_y(float value) {
  set_has_local_y();
  local_y_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.local_y)
}

// optional float local_z = 8 [(.dccl.field) = {
inline bool RelativePose::has_local_z() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RelativePose::set_has_local_z() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RelativePose::clear_has_local_z() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RelativePose::clear_local_z() {
  local_z_ = 0;
  clear_has_local_z();
}
inline float RelativePose::local_z() const {
  // @@protoc_insertion_point(field_get:RelativePose.local_z)
  return local_z_;
}
inline void RelativePose::set_local_z(float value) {
  set_has_local_z();
  local_z_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.local_z)
}

// optional float x_rot = 9 [(.dccl.field) = {
inline bool RelativePose::has_x_rot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RelativePose::set_has_x_rot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RelativePose::clear_has_x_rot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RelativePose::clear_x_rot() {
  x_rot_ = 0;
  clear_has_x_rot();
}
inline float RelativePose::x_rot() const {
  // @@protoc_insertion_point(field_get:RelativePose.x_rot)
  return x_rot_;
}
inline void RelativePose::set_x_rot(float value) {
  set_has_x_rot();
  x_rot_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.x_rot)
}

// optional int32 y_rot = 10 [(.dccl.field) = {
inline bool RelativePose::has_y_rot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RelativePose::set_has_y_rot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RelativePose::clear_has_y_rot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RelativePose::clear_y_rot() {
  y_rot_ = 0;
  clear_has_y_rot();
}
inline ::google::protobuf::int32 RelativePose::y_rot() const {
  // @@protoc_insertion_point(field_get:RelativePose.y_rot)
  return y_rot_;
}
inline void RelativePose::set_y_rot(::google::protobuf::int32 value) {
  set_has_y_rot();
  y_rot_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.y_rot)
}

// optional int32 z_rot = 11 [(.dccl.field) = {
inline bool RelativePose::has_z_rot() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RelativePose::set_has_z_rot() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RelativePose::clear_has_z_rot() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RelativePose::clear_z_rot() {
  z_rot_ = 0;
  clear_has_z_rot();
}
inline ::google::protobuf::int32 RelativePose::z_rot() const {
  // @@protoc_insertion_point(field_get:RelativePose.z_rot)
  return z_rot_;
}
inline void RelativePose::set_z_rot(::google::protobuf::int32 value) {
  set_has_z_rot();
  z_rot_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.z_rot)
}

// optional int32 w_rot = 12 [(.dccl.field) = {
inline bool RelativePose::has_w_rot() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RelativePose::set_has_w_rot() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RelativePose::clear_has_w_rot() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RelativePose::clear_w_rot() {
  w_rot_ = 0;
  clear_has_w_rot();
}
inline ::google::protobuf::int32 RelativePose::w_rot() const {
  // @@protoc_insertion_point(field_get:RelativePose.w_rot)
  return w_rot_;
}
inline void RelativePose::set_w_rot(::google::protobuf::int32 value) {
  set_has_w_rot();
  w_rot_ = value;
  // @@protoc_insertion_point(field_set:RelativePose.w_rot)
}

// -------------------------------------------------------------------

// ControllerInfo

// required int32 destination = 1 [(.dccl.field) = {
inline bool ControllerInfo::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerInfo::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerInfo::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerInfo::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ControllerInfo::destination() const {
  // @@protoc_insertion_point(field_get:ControllerInfo.destination)
  return destination_;
}
inline void ControllerInfo::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ControllerInfo.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool ControllerInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerInfo::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ControllerInfo::time() const {
  // @@protoc_insertion_point(field_get:ControllerInfo.time)
  return time_;
}
inline void ControllerInfo::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ControllerInfo.time)
}

// required bool setget = 3;
inline bool ControllerInfo::has_setget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerInfo::set_has_setget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerInfo::clear_has_setget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerInfo::clear_setget() {
  setget_ = false;
  clear_has_setget();
}
inline bool ControllerInfo::setget() const {
  // @@protoc_insertion_point(field_get:ControllerInfo.setget)
  return setget_;
}
inline void ControllerInfo::set_setget(bool value) {
  set_has_setget();
  setget_ = value;
  // @@protoc_insertion_point(field_set:ControllerInfo.setget)
}

// optional bool state = 4;
inline bool ControllerInfo::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerInfo::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerInfo::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool ControllerInfo::state() const {
  // @@protoc_insertion_point(field_get:ControllerInfo.state)
  return state_;
}
inline void ControllerInfo::set_state(bool value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ControllerInfo.state)
}

// -------------------------------------------------------------------

// DirectControl

// required int32 destination = 1 [(.dccl.field) = {
inline bool DirectControl::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectControl::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectControl::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectControl::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 DirectControl::destination() const {
  // @@protoc_insertion_point(field_get:DirectControl.destination)
  return destination_;
}
inline void DirectControl::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool DirectControl::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectControl::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectControl::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectControl::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double DirectControl::time() const {
  // @@protoc_insertion_point(field_get:DirectControl.time)
  return time_;
}
inline void DirectControl::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.time)
}

// required bool setget = 3;
inline bool DirectControl::has_setget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectControl::set_has_setget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectControl::clear_has_setget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectControl::clear_setget() {
  setget_ = false;
  clear_has_setget();
}
inline bool DirectControl::setget() const {
  // @@protoc_insertion_point(field_get:DirectControl.setget)
  return setget_;
}
inline void DirectControl::set_setget(bool value) {
  set_has_setget();
  setget_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.setget)
}

// optional .DirectControl.Frame frame = 4;
inline bool DirectControl::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectControl::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectControl::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectControl::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::DirectControl_Frame DirectControl::frame() const {
  // @@protoc_insertion_point(field_get:DirectControl.frame)
  return static_cast< ::DirectControl_Frame >(frame_);
}
inline void DirectControl::set_frame(::DirectControl_Frame value) {
  assert(::DirectControl_Frame_IsValid(value));
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.frame)
}

// optional float set_x = 6 [(.dccl.field) = {
inline bool DirectControl::has_set_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectControl::set_has_set_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectControl::clear_has_set_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectControl::clear_set_x() {
  set_x_ = 0;
  clear_has_set_x();
}
inline float DirectControl::set_x() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_x)
  return set_x_;
}
inline void DirectControl::set_set_x(float value) {
  set_has_set_x();
  set_x_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_x)
}

// optional float set_y = 7 [(.dccl.field) = {
inline bool DirectControl::has_set_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectControl::set_has_set_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectControl::clear_has_set_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectControl::clear_set_y() {
  set_y_ = 0;
  clear_has_set_y();
}
inline float DirectControl::set_y() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_y)
  return set_y_;
}
inline void DirectControl::set_set_y(float value) {
  set_has_set_y();
  set_y_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_y)
}

// optional float set_z = 8 [(.dccl.field) = {
inline bool DirectControl::has_set_z() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectControl::set_has_set_z() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectControl::clear_has_set_z() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectControl::clear_set_z() {
  set_z_ = 0;
  clear_has_set_z();
}
inline float DirectControl::set_z() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_z)
  return set_z_;
}
inline void DirectControl::set_set_z(float value) {
  set_has_set_z();
  set_z_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_z)
}

// optional float set_roll = 9 [(.dccl.field) = {
inline bool DirectControl::has_set_roll() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectControl::set_has_set_roll() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectControl::clear_has_set_roll() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectControl::clear_set_roll() {
  set_roll_ = 0;
  clear_has_set_roll();
}
inline float DirectControl::set_roll() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_roll)
  return set_roll_;
}
inline void DirectControl::set_set_roll(float value) {
  set_has_set_roll();
  set_roll_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_roll)
}

// optional float set_pitch = 10 [(.dccl.field) = {
inline bool DirectControl::has_set_pitch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectControl::set_has_set_pitch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectControl::clear_has_set_pitch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectControl::clear_set_pitch() {
  set_pitch_ = 0;
  clear_has_set_pitch();
}
inline float DirectControl::set_pitch() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_pitch)
  return set_pitch_;
}
inline void DirectControl::set_set_pitch(float value) {
  set_has_set_pitch();
  set_pitch_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_pitch)
}

// optional float set_yaw = 11 [(.dccl.field) = {
inline bool DirectControl::has_set_yaw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectControl::set_has_set_yaw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectControl::clear_has_set_yaw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectControl::clear_set_yaw() {
  set_yaw_ = 0;
  clear_has_set_yaw();
}
inline float DirectControl::set_yaw() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_yaw)
  return set_yaw_;
}
inline void DirectControl::set_set_yaw(float value) {
  set_has_set_yaw();
  set_yaw_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_yaw)
}

// optional float set_u = 12 [(.dccl.field) = {
inline bool DirectControl::has_set_u() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DirectControl::set_has_set_u() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DirectControl::clear_has_set_u() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DirectControl::clear_set_u() {
  set_u_ = 0;
  clear_has_set_u();
}
inline float DirectControl::set_u() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_u)
  return set_u_;
}
inline void DirectControl::set_set_u(float value) {
  set_has_set_u();
  set_u_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_u)
}

// optional float set_v = 13 [(.dccl.field) = {
inline bool DirectControl::has_set_v() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DirectControl::set_has_set_v() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DirectControl::clear_has_set_v() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DirectControl::clear_set_v() {
  set_v_ = 0;
  clear_has_set_v();
}
inline float DirectControl::set_v() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_v)
  return set_v_;
}
inline void DirectControl::set_set_v(float value) {
  set_has_set_v();
  set_v_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_v)
}

// optional float set_w = 14 [(.dccl.field) = {
inline bool DirectControl::has_set_w() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DirectControl::set_has_set_w() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DirectControl::clear_has_set_w() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DirectControl::clear_set_w() {
  set_w_ = 0;
  clear_has_set_w();
}
inline float DirectControl::set_w() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_w)
  return set_w_;
}
inline void DirectControl::set_set_w(float value) {
  set_has_set_w();
  set_w_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_w)
}

// optional float set_p = 15 [(.dccl.field) = {
inline bool DirectControl::has_set_p() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DirectControl::set_has_set_p() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DirectControl::clear_has_set_p() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DirectControl::clear_set_p() {
  set_p_ = 0;
  clear_has_set_p();
}
inline float DirectControl::set_p() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_p)
  return set_p_;
}
inline void DirectControl::set_set_p(float value) {
  set_has_set_p();
  set_p_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_p)
}

// optional float set_q = 16 [(.dccl.field) = {
inline bool DirectControl::has_set_q() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DirectControl::set_has_set_q() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DirectControl::clear_has_set_q() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DirectControl::clear_set_q() {
  set_q_ = 0;
  clear_has_set_q();
}
inline float DirectControl::set_q() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_q)
  return set_q_;
}
inline void DirectControl::set_set_q(float value) {
  set_has_set_q();
  set_q_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_q)
}

// optional float set_r = 17 [(.dccl.field) = {
inline bool DirectControl::has_set_r() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DirectControl::set_has_set_r() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DirectControl::clear_has_set_r() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DirectControl::clear_set_r() {
  set_r_ = 0;
  clear_has_set_r();
}
inline float DirectControl::set_r() const {
  // @@protoc_insertion_point(field_get:DirectControl.set_r)
  return set_r_;
}
inline void DirectControl::set_set_r(float value) {
  set_has_set_r();
  set_r_ = value;
  // @@protoc_insertion_point(field_set:DirectControl.set_r)
}

// -------------------------------------------------------------------

// StateInfo

// required int32 destination = 1 [(.dccl.field) = {
inline bool StateInfo::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateInfo::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateInfo::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateInfo::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 StateInfo::destination() const {
  // @@protoc_insertion_point(field_get:StateInfo.destination)
  return destination_;
}
inline void StateInfo::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:StateInfo.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool StateInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateInfo::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double StateInfo::time() const {
  // @@protoc_insertion_point(field_get:StateInfo.time)
  return time_;
}
inline void StateInfo::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:StateInfo.time)
}

// required bool setget = 3;
inline bool StateInfo::has_setget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateInfo::set_has_setget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateInfo::clear_has_setget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateInfo::clear_setget() {
  setget_ = false;
  clear_has_setget();
}
inline bool StateInfo::setget() const {
  // @@protoc_insertion_point(field_get:StateInfo.setget)
  return setget_;
}
inline void StateInfo::set_setget(bool value) {
  set_has_setget();
  setget_ = value;
  // @@protoc_insertion_point(field_set:StateInfo.setget)
}

// optional .StateInfo.State state = 4;
inline bool StateInfo::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateInfo::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StateInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::StateInfo_State StateInfo::state() const {
  // @@protoc_insertion_point(field_get:StateInfo.state)
  return static_cast< ::StateInfo_State >(state_);
}
inline void StateInfo::set_state(::StateInfo_State value) {
  assert(::StateInfo_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:StateInfo.state)
}

// -------------------------------------------------------------------

// SingleWaypoint

// required int32 destination = 1 [(.dccl.field) = {
inline bool SingleWaypoint::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleWaypoint::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleWaypoint::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleWaypoint::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 SingleWaypoint::destination() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.destination)
  return destination_;
}
inline void SingleWaypoint::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool SingleWaypoint::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleWaypoint::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleWaypoint::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleWaypoint::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SingleWaypoint::time() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.time)
  return time_;
}
inline void SingleWaypoint::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.time)
}

// required bool setget = 3;
inline bool SingleWaypoint::has_setget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleWaypoint::set_has_setget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleWaypoint::clear_has_setget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleWaypoint::clear_setget() {
  setget_ = false;
  clear_has_setget();
}
inline bool SingleWaypoint::setget() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.setget)
  return setget_;
}
inline void SingleWaypoint::set_setget(bool value) {
  set_has_setget();
  setget_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.setget)
}

// optional double latitude = 4 [(.dccl.field) = {
inline bool SingleWaypoint::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleWaypoint::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleWaypoint::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleWaypoint::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double SingleWaypoint::latitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.latitude)
  return latitude_;
}
inline void SingleWaypoint::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.latitude)
}

// optional double longitude = 5 [(.dccl.field) = {
inline bool SingleWaypoint::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleWaypoint::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleWaypoint::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleWaypoint::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double SingleWaypoint::longitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.longitude)
  return longitude_;
}
inline void SingleWaypoint::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.longitude)
}

// optional int32 local_x = 6 [(.dccl.field) = {
inline bool SingleWaypoint::has_local_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleWaypoint::set_has_local_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleWaypoint::clear_has_local_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleWaypoint::clear_local_x() {
  local_x_ = 0;
  clear_has_local_x();
}
inline ::google::protobuf::int32 SingleWaypoint::local_x() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.local_x)
  return local_x_;
}
inline void SingleWaypoint::set_local_x(::google::protobuf::int32 value) {
  set_has_local_x();
  local_x_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.local_x)
}

// optional int32 local_y = 7 [(.dccl.field) = {
inline bool SingleWaypoint::has_local_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SingleWaypoint::set_has_local_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SingleWaypoint::clear_has_local_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SingleWaypoint::clear_local_y() {
  local_y_ = 0;
  clear_has_local_y();
}
inline ::google::protobuf::int32 SingleWaypoint::local_y() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.local_y)
  return local_y_;
}
inline void SingleWaypoint::set_local_y(::google::protobuf::int32 value) {
  set_has_local_y();
  local_y_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.local_y)
}

// required int32 depth = 8 [(.dccl.field) = {
inline bool SingleWaypoint::has_depth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SingleWaypoint::set_has_depth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SingleWaypoint::clear_has_depth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SingleWaypoint::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline ::google::protobuf::int32 SingleWaypoint::depth() const {
  // @@protoc_insertion_point(field_get:SingleWaypoint.depth)
  return depth_;
}
inline void SingleWaypoint::set_depth(::google::protobuf::int32 value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypoint.depth)
}

// -------------------------------------------------------------------

// MultiWaypointGPS

// required int32 destination = 1 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointGPS::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointGPS::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointGPS::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointGPS::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.destination)
  return destination_;
}
inline void MultiWaypointGPS::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointGPS::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointGPS::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointGPS::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointGPS::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.time)
  return time_;
}
inline void MultiWaypointGPS::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.time)
}

// required int32 wpt_num = 3 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_wpt_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointGPS::set_has_wpt_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointGPS::clear_has_wpt_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointGPS::clear_wpt_num() {
  wpt_num_ = 0;
  clear_has_wpt_num();
}
inline ::google::protobuf::int32 MultiWaypointGPS::wpt_num() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.wpt_num)
  return wpt_num_;
}
inline void MultiWaypointGPS::set_wpt_num(::google::protobuf::int32 value) {
  set_has_wpt_num();
  wpt_num_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.wpt_num)
}

// optional double latitude_1 = 4 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_latitude_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointGPS::set_has_latitude_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointGPS::clear_has_latitude_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointGPS::clear_latitude_1() {
  latitude_1_ = 0;
  clear_has_latitude_1();
}
inline double MultiWaypointGPS::latitude_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.latitude_1)
  return latitude_1_;
}
inline void MultiWaypointGPS::set_latitude_1(double value) {
  set_has_latitude_1();
  latitude_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.latitude_1)
}

// optional double longitude_1 = 5 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_longitude_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointGPS::set_has_longitude_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointGPS::clear_has_longitude_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointGPS::clear_longitude_1() {
  longitude_1_ = 0;
  clear_has_longitude_1();
}
inline double MultiWaypointGPS::longitude_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.longitude_1)
  return longitude_1_;
}
inline void MultiWaypointGPS::set_longitude_1(double value) {
  set_has_longitude_1();
  longitude_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.longitude_1)
}

// optional int32 depth_1 = 6 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_depth_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiWaypointGPS::set_has_depth_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiWaypointGPS::clear_has_depth_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiWaypointGPS::clear_depth_1() {
  depth_1_ = 0;
  clear_has_depth_1();
}
inline ::google::protobuf::int32 MultiWaypointGPS::depth_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.depth_1)
  return depth_1_;
}
inline void MultiWaypointGPS::set_depth_1(::google::protobuf::int32 value) {
  set_has_depth_1();
  depth_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.depth_1)
}

// optional double latitude_2 = 7 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_latitude_2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiWaypointGPS::set_has_latitude_2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiWaypointGPS::clear_has_latitude_2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiWaypointGPS::clear_latitude_2() {
  latitude_2_ = 0;
  clear_has_latitude_2();
}
inline double MultiWaypointGPS::latitude_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.latitude_2)
  return latitude_2_;
}
inline void MultiWaypointGPS::set_latitude_2(double value) {
  set_has_latitude_2();
  latitude_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.latitude_2)
}

// optional double longitude_2 = 8 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_longitude_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MultiWaypointGPS::set_has_longitude_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MultiWaypointGPS::clear_has_longitude_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MultiWaypointGPS::clear_longitude_2() {
  longitude_2_ = 0;
  clear_has_longitude_2();
}
inline double MultiWaypointGPS::longitude_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.longitude_2)
  return longitude_2_;
}
inline void MultiWaypointGPS::set_longitude_2(double value) {
  set_has_longitude_2();
  longitude_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.longitude_2)
}

// optional int32 depth_2 = 9 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_depth_2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiWaypointGPS::set_has_depth_2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiWaypointGPS::clear_has_depth_2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiWaypointGPS::clear_depth_2() {
  depth_2_ = 0;
  clear_has_depth_2();
}
inline ::google::protobuf::int32 MultiWaypointGPS::depth_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.depth_2)
  return depth_2_;
}
inline void MultiWaypointGPS::set_depth_2(::google::protobuf::int32 value) {
  set_has_depth_2();
  depth_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.depth_2)
}

// optional double latitude_3 = 10 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_latitude_3() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MultiWaypointGPS::set_has_latitude_3() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MultiWaypointGPS::clear_has_latitude_3() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MultiWaypointGPS::clear_latitude_3() {
  latitude_3_ = 0;
  clear_has_latitude_3();
}
inline double MultiWaypointGPS::latitude_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.latitude_3)
  return latitude_3_;
}
inline void MultiWaypointGPS::set_latitude_3(double value) {
  set_has_latitude_3();
  latitude_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.latitude_3)
}

// optional double longitude_3 = 11 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_longitude_3() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MultiWaypointGPS::set_has_longitude_3() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MultiWaypointGPS::clear_has_longitude_3() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MultiWaypointGPS::clear_longitude_3() {
  longitude_3_ = 0;
  clear_has_longitude_3();
}
inline double MultiWaypointGPS::longitude_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.longitude_3)
  return longitude_3_;
}
inline void MultiWaypointGPS::set_longitude_3(double value) {
  set_has_longitude_3();
  longitude_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.longitude_3)
}

// optional int32 depth_3 = 12 [(.dccl.field) = {
inline bool MultiWaypointGPS::has_depth_3() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MultiWaypointGPS::set_has_depth_3() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MultiWaypointGPS::clear_has_depth_3() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MultiWaypointGPS::clear_depth_3() {
  depth_3_ = 0;
  clear_has_depth_3();
}
inline ::google::protobuf::int32 MultiWaypointGPS::depth_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.depth_3)
  return depth_3_;
}
inline void MultiWaypointGPS::set_depth_3(::google::protobuf::int32 value) {
  set_has_depth_3();
  depth_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.depth_3)
}

// required bool end = 13;
inline bool MultiWaypointGPS::has_end() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MultiWaypointGPS::set_has_end() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MultiWaypointGPS::clear_has_end() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MultiWaypointGPS::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointGPS::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPS.end)
  return end_;
}
inline void MultiWaypointGPS::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPS.end)
}

// -------------------------------------------------------------------

// MultiWaypointXYZ

// required int32 destination = 1 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointXYZ::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointXYZ::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointXYZ::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.destination)
  return destination_;
}
inline void MultiWaypointXYZ::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointXYZ::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointXYZ::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointXYZ::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointXYZ::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.time)
  return time_;
}
inline void MultiWaypointXYZ::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.time)
}

// required int32 wpt_num = 3 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_wpt_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointXYZ::set_has_wpt_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointXYZ::clear_has_wpt_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointXYZ::clear_wpt_num() {
  wpt_num_ = 0;
  clear_has_wpt_num();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::wpt_num() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.wpt_num)
  return wpt_num_;
}
inline void MultiWaypointXYZ::set_wpt_num(::google::protobuf::int32 value) {
  set_has_wpt_num();
  wpt_num_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.wpt_num)
}

// optional int32 x_1 = 4 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_x_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointXYZ::set_has_x_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointXYZ::clear_has_x_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointXYZ::clear_x_1() {
  x_1_ = 0;
  clear_has_x_1();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::x_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.x_1)
  return x_1_;
}
inline void MultiWaypointXYZ::set_x_1(::google::protobuf::int32 value) {
  set_has_x_1();
  x_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.x_1)
}

// optional int32 y_1 = 5 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_y_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointXYZ::set_has_y_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointXYZ::clear_has_y_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointXYZ::clear_y_1() {
  y_1_ = 0;
  clear_has_y_1();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::y_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.y_1)
  return y_1_;
}
inline void MultiWaypointXYZ::set_y_1(::google::protobuf::int32 value) {
  set_has_y_1();
  y_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.y_1)
}

// optional int32 depth_1 = 6 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_depth_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiWaypointXYZ::set_has_depth_1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiWaypointXYZ::clear_has_depth_1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiWaypointXYZ::clear_depth_1() {
  depth_1_ = 0;
  clear_has_depth_1();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::depth_1() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.depth_1)
  return depth_1_;
}
inline void MultiWaypointXYZ::set_depth_1(::google::protobuf::int32 value) {
  set_has_depth_1();
  depth_1_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.depth_1)
}

// optional int32 x_2 = 7 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_x_2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiWaypointXYZ::set_has_x_2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiWaypointXYZ::clear_has_x_2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiWaypointXYZ::clear_x_2() {
  x_2_ = 0;
  clear_has_x_2();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::x_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.x_2)
  return x_2_;
}
inline void MultiWaypointXYZ::set_x_2(::google::protobuf::int32 value) {
  set_has_x_2();
  x_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.x_2)
}

// optional int32 y_2 = 8 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_y_2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiWaypointXYZ::set_has_y_2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiWaypointXYZ::clear_has_y_2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiWaypointXYZ::clear_y_2() {
  y_2_ = 0;
  clear_has_y_2();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::y_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.y_2)
  return y_2_;
}
inline void MultiWaypointXYZ::set_y_2(::google::protobuf::int32 value) {
  set_has_y_2();
  y_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.y_2)
}

// optional int32 depth_2 = 9 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_depth_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MultiWaypointXYZ::set_has_depth_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MultiWaypointXYZ::clear_has_depth_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MultiWaypointXYZ::clear_depth_2() {
  depth_2_ = 0;
  clear_has_depth_2();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::depth_2() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.depth_2)
  return depth_2_;
}
inline void MultiWaypointXYZ::set_depth_2(::google::protobuf::int32 value) {
  set_has_depth_2();
  depth_2_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.depth_2)
}

// optional int32 x_3 = 10 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_x_3() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MultiWaypointXYZ::set_has_x_3() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MultiWaypointXYZ::clear_has_x_3() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MultiWaypointXYZ::clear_x_3() {
  x_3_ = 0;
  clear_has_x_3();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::x_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.x_3)
  return x_3_;
}
inline void MultiWaypointXYZ::set_x_3(::google::protobuf::int32 value) {
  set_has_x_3();
  x_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.x_3)
}

// optional int32 y_3 = 11 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_y_3() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MultiWaypointXYZ::set_has_y_3() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MultiWaypointXYZ::clear_has_y_3() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MultiWaypointXYZ::clear_y_3() {
  y_3_ = 0;
  clear_has_y_3();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::y_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.y_3)
  return y_3_;
}
inline void MultiWaypointXYZ::set_y_3(::google::protobuf::int32 value) {
  set_has_y_3();
  y_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.y_3)
}

// optional int32 depth_3 = 12 [(.dccl.field) = {
inline bool MultiWaypointXYZ::has_depth_3() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MultiWaypointXYZ::set_has_depth_3() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MultiWaypointXYZ::clear_has_depth_3() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MultiWaypointXYZ::clear_depth_3() {
  depth_3_ = 0;
  clear_has_depth_3();
}
inline ::google::protobuf::int32 MultiWaypointXYZ::depth_3() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.depth_3)
  return depth_3_;
}
inline void MultiWaypointXYZ::set_depth_3(::google::protobuf::int32 value) {
  set_has_depth_3();
  depth_3_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.depth_3)
}

// required bool end = 13;
inline bool MultiWaypointXYZ::has_end() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MultiWaypointXYZ::set_has_end() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MultiWaypointXYZ::clear_has_end() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MultiWaypointXYZ::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointXYZ::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZ.end)
  return end_;
}
inline void MultiWaypointXYZ::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZ.end)
}

// -------------------------------------------------------------------

// ExecuteWaypoints

// required int32 destination = 1 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteWaypoints::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteWaypoints::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteWaypoints::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ExecuteWaypoints::destination() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.destination)
  return destination_;
}
inline void ExecuteWaypoints::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.destination)
}

// required double time = 2 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteWaypoints::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteWaypoints::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteWaypoints::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ExecuteWaypoints::time() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.time)
  return time_;
}
inline void ExecuteWaypoints::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.time)
}

// required bool execute = 3;
inline bool ExecuteWaypoints::has_execute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecuteWaypoints::set_has_execute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecuteWaypoints::clear_has_execute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecuteWaypoints::clear_execute() {
  execute_ = false;
  clear_has_execute();
}
inline bool ExecuteWaypoints::execute() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.execute)
  return execute_;
}
inline void ExecuteWaypoints::set_execute(bool value) {
  set_has_execute();
  execute_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.execute)
}

// required .ExecuteWaypoints.WaypointMode mode = 4;
inline bool ExecuteWaypoints::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecuteWaypoints::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecuteWaypoints::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecuteWaypoints::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ExecuteWaypoints_WaypointMode ExecuteWaypoints::mode() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.mode)
  return static_cast< ::ExecuteWaypoints_WaypointMode >(mode_);
}
inline void ExecuteWaypoints::set_mode(::ExecuteWaypoints_WaypointMode value) {
  assert(::ExecuteWaypoints_WaypointMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RelativePose_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelativePose_Frame>() {
  return ::RelativePose_Frame_descriptor();
}
template <> struct is_proto_enum< ::DirectControl_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DirectControl_Frame>() {
  return ::DirectControl_Frame_descriptor();
}
template <> struct is_proto_enum< ::StateInfo_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StateInfo_State>() {
  return ::StateInfo_State_descriptor();
}
template <> struct is_proto_enum< ::ExecuteWaypoints_WaypointMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExecuteWaypoints_WaypointMode>() {
  return ::ExecuteWaypoints_WaypointMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goby_5fmsgs_2eproto
