// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goby_msgs.proto

#ifndef PROTOBUF_INCLUDED_goby_5fmsgs_2eproto
#define PROTOBUF_INCLUDED_goby_5fmsgs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dccl/option_extensions.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goby_5fmsgs_2eproto 

namespace protobuf_goby_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goby_5fmsgs_2eproto
class ControllerStateCommand;
class ControllerStateCommandDefaultTypeInternal;
extern ControllerStateCommandDefaultTypeInternal _ControllerStateCommand_default_instance_;
class ControllerStateResponse;
class ControllerStateResponseDefaultTypeInternal;
extern ControllerStateResponseDefaultTypeInternal _ControllerStateResponse_default_instance_;
class DirectControlCommand;
class DirectControlCommandDefaultTypeInternal;
extern DirectControlCommandDefaultTypeInternal _DirectControlCommand_default_instance_;
class ExecuteWaypoints;
class ExecuteWaypointsDefaultTypeInternal;
extern ExecuteWaypointsDefaultTypeInternal _ExecuteWaypoints_default_instance_;
class HealthCommand;
class HealthCommandDefaultTypeInternal;
extern HealthCommandDefaultTypeInternal _HealthCommand_default_instance_;
class HealthResponse;
class HealthResponseDefaultTypeInternal;
extern HealthResponseDefaultTypeInternal _HealthResponse_default_instance_;
class MultiWaypointGPSCommand;
class MultiWaypointGPSCommandDefaultTypeInternal;
extern MultiWaypointGPSCommandDefaultTypeInternal _MultiWaypointGPSCommand_default_instance_;
class MultiWaypointGPSResponse;
class MultiWaypointGPSResponseDefaultTypeInternal;
extern MultiWaypointGPSResponseDefaultTypeInternal _MultiWaypointGPSResponse_default_instance_;
class MultiWaypointXYZCommand;
class MultiWaypointXYZCommandDefaultTypeInternal;
extern MultiWaypointXYZCommandDefaultTypeInternal _MultiWaypointXYZCommand_default_instance_;
class MultiWaypointXYZResponse;
class MultiWaypointXYZResponseDefaultTypeInternal;
extern MultiWaypointXYZResponseDefaultTypeInternal _MultiWaypointXYZResponse_default_instance_;
class PoseCommand;
class PoseCommandDefaultTypeInternal;
extern PoseCommandDefaultTypeInternal _PoseCommand_default_instance_;
class PoseResponse;
class PoseResponseDefaultTypeInternal;
extern PoseResponseDefaultTypeInternal _PoseResponse_default_instance_;
class RelativePoseCommand;
class RelativePoseCommandDefaultTypeInternal;
extern RelativePoseCommandDefaultTypeInternal _RelativePoseCommand_default_instance_;
class RelativePoseResponse;
class RelativePoseResponseDefaultTypeInternal;
extern RelativePoseResponseDefaultTypeInternal _RelativePoseResponse_default_instance_;
class SingleWaypointCommand;
class SingleWaypointCommandDefaultTypeInternal;
extern SingleWaypointCommandDefaultTypeInternal _SingleWaypointCommand_default_instance_;
class SingleWaypointResponse;
class SingleWaypointResponseDefaultTypeInternal;
extern SingleWaypointResponseDefaultTypeInternal _SingleWaypointResponse_default_instance_;
class StateCommand;
class StateCommandDefaultTypeInternal;
extern StateCommandDefaultTypeInternal _StateCommand_default_instance_;
class StateResponse;
class StateResponseDefaultTypeInternal;
extern StateResponseDefaultTypeInternal _StateResponse_default_instance_;
namespace google {
namespace protobuf {
template<> ::ControllerStateCommand* Arena::CreateMaybeMessage<::ControllerStateCommand>(Arena*);
template<> ::ControllerStateResponse* Arena::CreateMaybeMessage<::ControllerStateResponse>(Arena*);
template<> ::DirectControlCommand* Arena::CreateMaybeMessage<::DirectControlCommand>(Arena*);
template<> ::ExecuteWaypoints* Arena::CreateMaybeMessage<::ExecuteWaypoints>(Arena*);
template<> ::HealthCommand* Arena::CreateMaybeMessage<::HealthCommand>(Arena*);
template<> ::HealthResponse* Arena::CreateMaybeMessage<::HealthResponse>(Arena*);
template<> ::MultiWaypointGPSCommand* Arena::CreateMaybeMessage<::MultiWaypointGPSCommand>(Arena*);
template<> ::MultiWaypointGPSResponse* Arena::CreateMaybeMessage<::MultiWaypointGPSResponse>(Arena*);
template<> ::MultiWaypointXYZCommand* Arena::CreateMaybeMessage<::MultiWaypointXYZCommand>(Arena*);
template<> ::MultiWaypointXYZResponse* Arena::CreateMaybeMessage<::MultiWaypointXYZResponse>(Arena*);
template<> ::PoseCommand* Arena::CreateMaybeMessage<::PoseCommand>(Arena*);
template<> ::PoseResponse* Arena::CreateMaybeMessage<::PoseResponse>(Arena*);
template<> ::RelativePoseCommand* Arena::CreateMaybeMessage<::RelativePoseCommand>(Arena*);
template<> ::RelativePoseResponse* Arena::CreateMaybeMessage<::RelativePoseResponse>(Arena*);
template<> ::SingleWaypointCommand* Arena::CreateMaybeMessage<::SingleWaypointCommand>(Arena*);
template<> ::SingleWaypointResponse* Arena::CreateMaybeMessage<::SingleWaypointResponse>(Arena*);
template<> ::StateCommand* Arena::CreateMaybeMessage<::StateCommand>(Arena*);
template<> ::StateResponse* Arena::CreateMaybeMessage<::StateResponse>(Arena*);
}  // namespace protobuf
}  // namespace google

enum RelativePoseCommand_Frame {
  RelativePoseCommand_Frame_BASE_LINK = 0,
  RelativePoseCommand_Frame_ODOM = 1,
  RelativePoseCommand_Frame_WORLD = 2,
  RelativePoseCommand_Frame_USBL = 3
};
bool RelativePoseCommand_Frame_IsValid(int value);
const RelativePoseCommand_Frame RelativePoseCommand_Frame_Frame_MIN = RelativePoseCommand_Frame_BASE_LINK;
const RelativePoseCommand_Frame RelativePoseCommand_Frame_Frame_MAX = RelativePoseCommand_Frame_USBL;
const int RelativePoseCommand_Frame_Frame_ARRAYSIZE = RelativePoseCommand_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativePoseCommand_Frame_descriptor();
inline const ::std::string& RelativePoseCommand_Frame_Name(RelativePoseCommand_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativePoseCommand_Frame_descriptor(), value);
}
inline bool RelativePoseCommand_Frame_Parse(
    const ::std::string& name, RelativePoseCommand_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativePoseCommand_Frame>(
    RelativePoseCommand_Frame_descriptor(), name, value);
}
enum RelativePoseResponse_Frame {
  RelativePoseResponse_Frame_BASE_LINK = 0,
  RelativePoseResponse_Frame_ODOM = 1,
  RelativePoseResponse_Frame_WORLD = 2,
  RelativePoseResponse_Frame_USBL = 3
};
bool RelativePoseResponse_Frame_IsValid(int value);
const RelativePoseResponse_Frame RelativePoseResponse_Frame_Frame_MIN = RelativePoseResponse_Frame_BASE_LINK;
const RelativePoseResponse_Frame RelativePoseResponse_Frame_Frame_MAX = RelativePoseResponse_Frame_USBL;
const int RelativePoseResponse_Frame_Frame_ARRAYSIZE = RelativePoseResponse_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativePoseResponse_Frame_descriptor();
inline const ::std::string& RelativePoseResponse_Frame_Name(RelativePoseResponse_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativePoseResponse_Frame_descriptor(), value);
}
inline bool RelativePoseResponse_Frame_Parse(
    const ::std::string& name, RelativePoseResponse_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativePoseResponse_Frame>(
    RelativePoseResponse_Frame_descriptor(), name, value);
}
enum ControllerStateCommand_State {
  ControllerStateCommand_State_DISABLE = 0,
  ControllerStateCommand_State_ENABLE = 1
};
bool ControllerStateCommand_State_IsValid(int value);
const ControllerStateCommand_State ControllerStateCommand_State_State_MIN = ControllerStateCommand_State_DISABLE;
const ControllerStateCommand_State ControllerStateCommand_State_State_MAX = ControllerStateCommand_State_ENABLE;
const int ControllerStateCommand_State_State_ARRAYSIZE = ControllerStateCommand_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerStateCommand_State_descriptor();
inline const ::std::string& ControllerStateCommand_State_Name(ControllerStateCommand_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerStateCommand_State_descriptor(), value);
}
inline bool ControllerStateCommand_State_Parse(
    const ::std::string& name, ControllerStateCommand_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerStateCommand_State>(
    ControllerStateCommand_State_descriptor(), name, value);
}
enum ControllerStateResponse_State {
  ControllerStateResponse_State_DISABLE = 0,
  ControllerStateResponse_State_ENABLE = 1
};
bool ControllerStateResponse_State_IsValid(int value);
const ControllerStateResponse_State ControllerStateResponse_State_State_MIN = ControllerStateResponse_State_DISABLE;
const ControllerStateResponse_State ControllerStateResponse_State_State_MAX = ControllerStateResponse_State_ENABLE;
const int ControllerStateResponse_State_State_ARRAYSIZE = ControllerStateResponse_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerStateResponse_State_descriptor();
inline const ::std::string& ControllerStateResponse_State_Name(ControllerStateResponse_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerStateResponse_State_descriptor(), value);
}
inline bool ControllerStateResponse_State_Parse(
    const ::std::string& name, ControllerStateResponse_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerStateResponse_State>(
    ControllerStateResponse_State_descriptor(), name, value);
}
enum DirectControlCommand_Frame {
  DirectControlCommand_Frame_BASE_LINK = 0,
  DirectControlCommand_Frame_ODOM = 1,
  DirectControlCommand_Frame_WORLD = 2,
  DirectControlCommand_Frame_USBL = 3
};
bool DirectControlCommand_Frame_IsValid(int value);
const DirectControlCommand_Frame DirectControlCommand_Frame_Frame_MIN = DirectControlCommand_Frame_BASE_LINK;
const DirectControlCommand_Frame DirectControlCommand_Frame_Frame_MAX = DirectControlCommand_Frame_USBL;
const int DirectControlCommand_Frame_Frame_ARRAYSIZE = DirectControlCommand_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectControlCommand_Frame_descriptor();
inline const ::std::string& DirectControlCommand_Frame_Name(DirectControlCommand_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectControlCommand_Frame_descriptor(), value);
}
inline bool DirectControlCommand_Frame_Parse(
    const ::std::string& name, DirectControlCommand_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectControlCommand_Frame>(
    DirectControlCommand_Frame_descriptor(), name, value);
}
enum StateCommand_Mode {
  StateCommand_Mode_QUERY = 0,
  StateCommand_Mode_COMMAND = 1
};
bool StateCommand_Mode_IsValid(int value);
const StateCommand_Mode StateCommand_Mode_Mode_MIN = StateCommand_Mode_QUERY;
const StateCommand_Mode StateCommand_Mode_Mode_MAX = StateCommand_Mode_COMMAND;
const int StateCommand_Mode_Mode_ARRAYSIZE = StateCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StateCommand_Mode_descriptor();
inline const ::std::string& StateCommand_Mode_Name(StateCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StateCommand_Mode_descriptor(), value);
}
inline bool StateCommand_Mode_Parse(
    const ::std::string& name, StateCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateCommand_Mode>(
    StateCommand_Mode_descriptor(), name, value);
}
enum StateCommand_State {
  StateCommand_State_KILL = 0,
  StateCommand_State_START = 1,
  StateCommand_State_SURVEY_LOCAL = 2,
  StateCommand_State_SURVEY_GLOBAL = 3,
  StateCommand_State_DIRECT_CONTROL = 4,
  StateCommand_State_SURVEY_3D = 5
};
bool StateCommand_State_IsValid(int value);
const StateCommand_State StateCommand_State_State_MIN = StateCommand_State_KILL;
const StateCommand_State StateCommand_State_State_MAX = StateCommand_State_SURVEY_3D;
const int StateCommand_State_State_ARRAYSIZE = StateCommand_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* StateCommand_State_descriptor();
inline const ::std::string& StateCommand_State_Name(StateCommand_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    StateCommand_State_descriptor(), value);
}
inline bool StateCommand_State_Parse(
    const ::std::string& name, StateCommand_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateCommand_State>(
    StateCommand_State_descriptor(), name, value);
}
enum StateResponse_State {
  StateResponse_State_KILL = 0,
  StateResponse_State_START = 1,
  StateResponse_State_SURVEY_LOCAL = 2,
  StateResponse_State_SURVEY_GLOBAL = 3,
  StateResponse_State_DIRECT_CONTROL = 4,
  StateResponse_State_SURVEY_3D = 5
};
bool StateResponse_State_IsValid(int value);
const StateResponse_State StateResponse_State_State_MIN = StateResponse_State_KILL;
const StateResponse_State StateResponse_State_State_MAX = StateResponse_State_SURVEY_3D;
const int StateResponse_State_State_ARRAYSIZE = StateResponse_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* StateResponse_State_descriptor();
inline const ::std::string& StateResponse_State_Name(StateResponse_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    StateResponse_State_descriptor(), value);
}
inline bool StateResponse_State_Parse(
    const ::std::string& name, StateResponse_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateResponse_State>(
    StateResponse_State_descriptor(), name, value);
}
enum SingleWaypointCommand_Mode {
  SingleWaypointCommand_Mode_QUERY = 0,
  SingleWaypointCommand_Mode_COMMAND_LATLONG = 1,
  SingleWaypointCommand_Mode_COMMAND_XYZ = 2
};
bool SingleWaypointCommand_Mode_IsValid(int value);
const SingleWaypointCommand_Mode SingleWaypointCommand_Mode_Mode_MIN = SingleWaypointCommand_Mode_QUERY;
const SingleWaypointCommand_Mode SingleWaypointCommand_Mode_Mode_MAX = SingleWaypointCommand_Mode_COMMAND_XYZ;
const int SingleWaypointCommand_Mode_Mode_ARRAYSIZE = SingleWaypointCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SingleWaypointCommand_Mode_descriptor();
inline const ::std::string& SingleWaypointCommand_Mode_Name(SingleWaypointCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SingleWaypointCommand_Mode_descriptor(), value);
}
inline bool SingleWaypointCommand_Mode_Parse(
    const ::std::string& name, SingleWaypointCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SingleWaypointCommand_Mode>(
    SingleWaypointCommand_Mode_descriptor(), name, value);
}
enum MultiWaypointGPSCommand_Mode {
  MultiWaypointGPSCommand_Mode_QUERY = 0,
  MultiWaypointGPSCommand_Mode_COMMAND = 1
};
bool MultiWaypointGPSCommand_Mode_IsValid(int value);
const MultiWaypointGPSCommand_Mode MultiWaypointGPSCommand_Mode_Mode_MIN = MultiWaypointGPSCommand_Mode_QUERY;
const MultiWaypointGPSCommand_Mode MultiWaypointGPSCommand_Mode_Mode_MAX = MultiWaypointGPSCommand_Mode_COMMAND;
const int MultiWaypointGPSCommand_Mode_Mode_ARRAYSIZE = MultiWaypointGPSCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiWaypointGPSCommand_Mode_descriptor();
inline const ::std::string& MultiWaypointGPSCommand_Mode_Name(MultiWaypointGPSCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiWaypointGPSCommand_Mode_descriptor(), value);
}
inline bool MultiWaypointGPSCommand_Mode_Parse(
    const ::std::string& name, MultiWaypointGPSCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiWaypointGPSCommand_Mode>(
    MultiWaypointGPSCommand_Mode_descriptor(), name, value);
}
enum MultiWaypointGPSResponse_Mode {
  MultiWaypointGPSResponse_Mode_QUERY = 0,
  MultiWaypointGPSResponse_Mode_COMMAND = 1
};
bool MultiWaypointGPSResponse_Mode_IsValid(int value);
const MultiWaypointGPSResponse_Mode MultiWaypointGPSResponse_Mode_Mode_MIN = MultiWaypointGPSResponse_Mode_QUERY;
const MultiWaypointGPSResponse_Mode MultiWaypointGPSResponse_Mode_Mode_MAX = MultiWaypointGPSResponse_Mode_COMMAND;
const int MultiWaypointGPSResponse_Mode_Mode_ARRAYSIZE = MultiWaypointGPSResponse_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiWaypointGPSResponse_Mode_descriptor();
inline const ::std::string& MultiWaypointGPSResponse_Mode_Name(MultiWaypointGPSResponse_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiWaypointGPSResponse_Mode_descriptor(), value);
}
inline bool MultiWaypointGPSResponse_Mode_Parse(
    const ::std::string& name, MultiWaypointGPSResponse_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiWaypointGPSResponse_Mode>(
    MultiWaypointGPSResponse_Mode_descriptor(), name, value);
}
enum MultiWaypointXYZCommand_Mode {
  MultiWaypointXYZCommand_Mode_QUERY = 0,
  MultiWaypointXYZCommand_Mode_COMMAND = 1
};
bool MultiWaypointXYZCommand_Mode_IsValid(int value);
const MultiWaypointXYZCommand_Mode MultiWaypointXYZCommand_Mode_Mode_MIN = MultiWaypointXYZCommand_Mode_QUERY;
const MultiWaypointXYZCommand_Mode MultiWaypointXYZCommand_Mode_Mode_MAX = MultiWaypointXYZCommand_Mode_COMMAND;
const int MultiWaypointXYZCommand_Mode_Mode_ARRAYSIZE = MultiWaypointXYZCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiWaypointXYZCommand_Mode_descriptor();
inline const ::std::string& MultiWaypointXYZCommand_Mode_Name(MultiWaypointXYZCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiWaypointXYZCommand_Mode_descriptor(), value);
}
inline bool MultiWaypointXYZCommand_Mode_Parse(
    const ::std::string& name, MultiWaypointXYZCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiWaypointXYZCommand_Mode>(
    MultiWaypointXYZCommand_Mode_descriptor(), name, value);
}
enum ExecuteWaypoints_WaypointMode {
  ExecuteWaypoints_WaypointMode_APPEND = 0,
  ExecuteWaypoints_WaypointMode_UPDATE = 1
};
bool ExecuteWaypoints_WaypointMode_IsValid(int value);
const ExecuteWaypoints_WaypointMode ExecuteWaypoints_WaypointMode_WaypointMode_MIN = ExecuteWaypoints_WaypointMode_APPEND;
const ExecuteWaypoints_WaypointMode ExecuteWaypoints_WaypointMode_WaypointMode_MAX = ExecuteWaypoints_WaypointMode_UPDATE;
const int ExecuteWaypoints_WaypointMode_WaypointMode_ARRAYSIZE = ExecuteWaypoints_WaypointMode_WaypointMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteWaypoints_WaypointMode_descriptor();
inline const ::std::string& ExecuteWaypoints_WaypointMode_Name(ExecuteWaypoints_WaypointMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteWaypoints_WaypointMode_descriptor(), value);
}
inline bool ExecuteWaypoints_WaypointMode_Parse(
    const ::std::string& name, ExecuteWaypoints_WaypointMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteWaypoints_WaypointMode>(
    ExecuteWaypoints_WaypointMode_descriptor(), name, value);
}
// ===================================================================

class PoseCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PoseCommand) */ {
 public:
  PoseCommand();
  virtual ~PoseCommand();

  PoseCommand(const PoseCommand& from);

  inline PoseCommand& operator=(const PoseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseCommand(PoseCommand&& from) noexcept
    : PoseCommand() {
    *this = ::std::move(from);
  }

  inline PoseCommand& operator=(PoseCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseCommand* internal_default_instance() {
    return reinterpret_cast<const PoseCommand*>(
               &_PoseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PoseCommand* other);
  friend void swap(PoseCommand& a, PoseCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseCommand* New() const final {
    return CreateMaybeMessage<PoseCommand>(NULL);
  }

  PoseCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoseCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoseCommand& from);
  void MergeFrom(const PoseCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:PoseCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PoseResponse) */ {
 public:
  PoseResponse();
  virtual ~PoseResponse();

  PoseResponse(const PoseResponse& from);

  inline PoseResponse& operator=(const PoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseResponse(PoseResponse&& from) noexcept
    : PoseResponse() {
    *this = ::std::move(from);
  }

  inline PoseResponse& operator=(PoseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseResponse* internal_default_instance() {
    return reinterpret_cast<const PoseResponse*>(
               &_PoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PoseResponse* other);
  friend void swap(PoseResponse& a, PoseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseResponse* New() const final {
    return CreateMaybeMessage<PoseResponse>(NULL);
  }

  PoseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoseResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoseResponse& from);
  void MergeFrom(const PoseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required double latitude = 4 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 5 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // required float x = 6 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 6;
  float x() const;
  void set_x(float value);

  // required float y = 7 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 7;
  float y() const;
  void set_y(float value);

  // required float z = 8 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z() const;
  void set_z(float value);

  // required float quat_x = 9 [(.dccl.field) = {
  bool has_quat_x() const;
  void clear_quat_x();
  static const int kQuatXFieldNumber = 9;
  float quat_x() const;
  void set_quat_x(float value);

  // required float quat_y = 10 [(.dccl.field) = {
  bool has_quat_y() const;
  void clear_quat_y();
  static const int kQuatYFieldNumber = 10;
  float quat_y() const;
  void set_quat_y(float value);

  // required float quat_z = 11 [(.dccl.field) = {
  bool has_quat_z() const;
  void clear_quat_z();
  static const int kQuatZFieldNumber = 11;
  float quat_z() const;
  void set_quat_z(float value);

  // required float quat_w = 12 [(.dccl.field) = {
  bool has_quat_w() const;
  void clear_quat_w();
  static const int kQuatWFieldNumber = 12;
  float quat_w() const;
  void set_quat_w(float value);

  // @@protoc_insertion_point(class_scope:PoseResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_quat_x();
  void clear_has_quat_x();
  void set_has_quat_y();
  void clear_has_quat_y();
  void set_has_quat_z();
  void clear_has_quat_z();
  void set_has_quat_w();
  void clear_has_quat_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  double latitude_;
  double longitude_;
  float x_;
  float y_;
  float z_;
  float quat_x_;
  float quat_y_;
  float quat_z_;
  float quat_w_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HealthCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HealthCommand) */ {
 public:
  HealthCommand();
  virtual ~HealthCommand();

  HealthCommand(const HealthCommand& from);

  inline HealthCommand& operator=(const HealthCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthCommand(HealthCommand&& from) noexcept
    : HealthCommand() {
    *this = ::std::move(from);
  }

  inline HealthCommand& operator=(HealthCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCommand* internal_default_instance() {
    return reinterpret_cast<const HealthCommand*>(
               &_HealthCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HealthCommand* other);
  friend void swap(HealthCommand& a, HealthCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthCommand* New() const final {
    return CreateMaybeMessage<HealthCommand>(NULL);
  }

  HealthCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HealthCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HealthCommand& from);
  void MergeFrom(const HealthCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:HealthCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HealthResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HealthResponse) */ {
 public:
  HealthResponse();
  virtual ~HealthResponse();

  HealthResponse(const HealthResponse& from);

  inline HealthResponse& operator=(const HealthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthResponse(HealthResponse&& from) noexcept
    : HealthResponse() {
    *this = ::std::move(from);
  }

  inline HealthResponse& operator=(HealthResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthResponse* internal_default_instance() {
    return reinterpret_cast<const HealthResponse*>(
               &_HealthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(HealthResponse* other);
  friend void swap(HealthResponse& a, HealthResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthResponse* New() const final {
    return CreateMaybeMessage<HealthResponse>(NULL);
  }

  HealthResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HealthResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HealthResponse& from);
  void MergeFrom(const HealthResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required float batt_volt = 4 [(.dccl.field) = {
  bool has_batt_volt() const;
  void clear_batt_volt();
  static const int kBattVoltFieldNumber = 4;
  float batt_volt() const;
  void set_batt_volt(float value);

  // required float current = 5 [(.dccl.field) = {
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 5;
  float current() const;
  void set_current(float value);

  // @@protoc_insertion_point(class_scope:HealthResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_batt_volt();
  void clear_has_batt_volt();
  void set_has_current();
  void clear_has_current();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  float batt_volt_;
  float current_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePoseCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RelativePoseCommand) */ {
 public:
  RelativePoseCommand();
  virtual ~RelativePoseCommand();

  RelativePoseCommand(const RelativePoseCommand& from);

  inline RelativePoseCommand& operator=(const RelativePoseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePoseCommand(RelativePoseCommand&& from) noexcept
    : RelativePoseCommand() {
    *this = ::std::move(from);
  }

  inline RelativePoseCommand& operator=(RelativePoseCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePoseCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePoseCommand* internal_default_instance() {
    return reinterpret_cast<const RelativePoseCommand*>(
               &_RelativePoseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RelativePoseCommand* other);
  friend void swap(RelativePoseCommand& a, RelativePoseCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePoseCommand* New() const final {
    return CreateMaybeMessage<RelativePoseCommand>(NULL);
  }

  RelativePoseCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePoseCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePoseCommand& from);
  void MergeFrom(const RelativePoseCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePoseCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelativePoseCommand_Frame Frame;
  static const Frame BASE_LINK =
    RelativePoseCommand_Frame_BASE_LINK;
  static const Frame ODOM =
    RelativePoseCommand_Frame_ODOM;
  static const Frame WORLD =
    RelativePoseCommand_Frame_WORLD;
  static const Frame USBL =
    RelativePoseCommand_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return RelativePoseCommand_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    RelativePoseCommand_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    RelativePoseCommand_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    RelativePoseCommand_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return RelativePoseCommand_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return RelativePoseCommand_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return RelativePoseCommand_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .RelativePoseCommand.Frame parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  ::RelativePoseCommand_Frame parent() const;
  void set_parent(::RelativePoseCommand_Frame value);

  // required .RelativePoseCommand.Frame child = 5;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::RelativePoseCommand_Frame child() const;
  void set_child(::RelativePoseCommand_Frame value);

  // @@protoc_insertion_point(class_scope:RelativePoseCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_parent();
  void clear_has_parent();
  void set_has_child();
  void clear_has_child();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int parent_;
  int child_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePoseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RelativePoseResponse) */ {
 public:
  RelativePoseResponse();
  virtual ~RelativePoseResponse();

  RelativePoseResponse(const RelativePoseResponse& from);

  inline RelativePoseResponse& operator=(const RelativePoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePoseResponse(RelativePoseResponse&& from) noexcept
    : RelativePoseResponse() {
    *this = ::std::move(from);
  }

  inline RelativePoseResponse& operator=(RelativePoseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePoseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePoseResponse* internal_default_instance() {
    return reinterpret_cast<const RelativePoseResponse*>(
               &_RelativePoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RelativePoseResponse* other);
  friend void swap(RelativePoseResponse& a, RelativePoseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePoseResponse* New() const final {
    return CreateMaybeMessage<RelativePoseResponse>(NULL);
  }

  RelativePoseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePoseResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePoseResponse& from);
  void MergeFrom(const RelativePoseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePoseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelativePoseResponse_Frame Frame;
  static const Frame BASE_LINK =
    RelativePoseResponse_Frame_BASE_LINK;
  static const Frame ODOM =
    RelativePoseResponse_Frame_ODOM;
  static const Frame WORLD =
    RelativePoseResponse_Frame_WORLD;
  static const Frame USBL =
    RelativePoseResponse_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return RelativePoseResponse_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    RelativePoseResponse_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    RelativePoseResponse_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    RelativePoseResponse_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return RelativePoseResponse_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return RelativePoseResponse_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return RelativePoseResponse_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .RelativePoseResponse.Frame parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  ::RelativePoseResponse_Frame parent() const;
  void set_parent(::RelativePoseResponse_Frame value);

  // required .RelativePoseResponse.Frame child = 5;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::RelativePoseResponse_Frame child() const;
  void set_child(::RelativePoseResponse_Frame value);

  // required double latitude = 6 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 7 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 7;
  double longitude() const;
  void set_longitude(double value);

  // required float x = 8 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 8;
  float x() const;
  void set_x(float value);

  // required float y = 9 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 9;
  float y() const;
  void set_y(float value);

  // required float z = 10 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 10;
  float z() const;
  void set_z(float value);

  // required float quat_x = 11 [(.dccl.field) = {
  bool has_quat_x() const;
  void clear_quat_x();
  static const int kQuatXFieldNumber = 11;
  float quat_x() const;
  void set_quat_x(float value);

  // required float quat_y = 12 [(.dccl.field) = {
  bool has_quat_y() const;
  void clear_quat_y();
  static const int kQuatYFieldNumber = 12;
  float quat_y() const;
  void set_quat_y(float value);

  // required float quat_z = 13 [(.dccl.field) = {
  bool has_quat_z() const;
  void clear_quat_z();
  static const int kQuatZFieldNumber = 13;
  float quat_z() const;
  void set_quat_z(float value);

  // required float quat_w = 14 [(.dccl.field) = {
  bool has_quat_w() const;
  void clear_quat_w();
  static const int kQuatWFieldNumber = 14;
  float quat_w() const;
  void set_quat_w(float value);

  // @@protoc_insertion_point(class_scope:RelativePoseResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_parent();
  void clear_has_parent();
  void set_has_child();
  void clear_has_child();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_quat_x();
  void clear_has_quat_x();
  void set_has_quat_y();
  void clear_has_quat_y();
  void set_has_quat_z();
  void clear_has_quat_z();
  void set_has_quat_w();
  void clear_has_quat_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int parent_;
  int child_;
  double latitude_;
  double longitude_;
  float x_;
  float y_;
  float z_;
  float quat_x_;
  float quat_y_;
  float quat_z_;
  float quat_w_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerStateCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControllerStateCommand) */ {
 public:
  ControllerStateCommand();
  virtual ~ControllerStateCommand();

  ControllerStateCommand(const ControllerStateCommand& from);

  inline ControllerStateCommand& operator=(const ControllerStateCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerStateCommand(ControllerStateCommand&& from) noexcept
    : ControllerStateCommand() {
    *this = ::std::move(from);
  }

  inline ControllerStateCommand& operator=(ControllerStateCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerStateCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerStateCommand* internal_default_instance() {
    return reinterpret_cast<const ControllerStateCommand*>(
               &_ControllerStateCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ControllerStateCommand* other);
  friend void swap(ControllerStateCommand& a, ControllerStateCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerStateCommand* New() const final {
    return CreateMaybeMessage<ControllerStateCommand>(NULL);
  }

  ControllerStateCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControllerStateCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControllerStateCommand& from);
  void MergeFrom(const ControllerStateCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerStateCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControllerStateCommand_State State;
  static const State DISABLE =
    ControllerStateCommand_State_DISABLE;
  static const State ENABLE =
    ControllerStateCommand_State_ENABLE;
  static inline bool State_IsValid(int value) {
    return ControllerStateCommand_State_IsValid(value);
  }
  static const State State_MIN =
    ControllerStateCommand_State_State_MIN;
  static const State State_MAX =
    ControllerStateCommand_State_State_MAX;
  static const int State_ARRAYSIZE =
    ControllerStateCommand_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ControllerStateCommand_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ControllerStateCommand_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ControllerStateCommand_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .ControllerStateCommand.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::ControllerStateCommand_State state() const;
  void set_state(::ControllerStateCommand_State value);

  // @@protoc_insertion_point(class_scope:ControllerStateCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControllerStateResponse) */ {
 public:
  ControllerStateResponse();
  virtual ~ControllerStateResponse();

  ControllerStateResponse(const ControllerStateResponse& from);

  inline ControllerStateResponse& operator=(const ControllerStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerStateResponse(ControllerStateResponse&& from) noexcept
    : ControllerStateResponse() {
    *this = ::std::move(from);
  }

  inline ControllerStateResponse& operator=(ControllerStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerStateResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerStateResponse*>(
               &_ControllerStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ControllerStateResponse* other);
  friend void swap(ControllerStateResponse& a, ControllerStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerStateResponse* New() const final {
    return CreateMaybeMessage<ControllerStateResponse>(NULL);
  }

  ControllerStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControllerStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControllerStateResponse& from);
  void MergeFrom(const ControllerStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControllerStateResponse_State State;
  static const State DISABLE =
    ControllerStateResponse_State_DISABLE;
  static const State ENABLE =
    ControllerStateResponse_State_ENABLE;
  static inline bool State_IsValid(int value) {
    return ControllerStateResponse_State_IsValid(value);
  }
  static const State State_MIN =
    ControllerStateResponse_State_State_MIN;
  static const State State_MAX =
    ControllerStateResponse_State_State_MAX;
  static const int State_ARRAYSIZE =
    ControllerStateResponse_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ControllerStateResponse_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ControllerStateResponse_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ControllerStateResponse_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .ControllerStateResponse.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::ControllerStateResponse_State state() const;
  void set_state(::ControllerStateResponse_State value);

  // @@protoc_insertion_point(class_scope:ControllerStateResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectControlCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DirectControlCommand) */ {
 public:
  DirectControlCommand();
  virtual ~DirectControlCommand();

  DirectControlCommand(const DirectControlCommand& from);

  inline DirectControlCommand& operator=(const DirectControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectControlCommand(DirectControlCommand&& from) noexcept
    : DirectControlCommand() {
    *this = ::std::move(from);
  }

  inline DirectControlCommand& operator=(DirectControlCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectControlCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectControlCommand* internal_default_instance() {
    return reinterpret_cast<const DirectControlCommand*>(
               &_DirectControlCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DirectControlCommand* other);
  friend void swap(DirectControlCommand& a, DirectControlCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectControlCommand* New() const final {
    return CreateMaybeMessage<DirectControlCommand>(NULL);
  }

  DirectControlCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectControlCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectControlCommand& from);
  void MergeFrom(const DirectControlCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectControlCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DirectControlCommand_Frame Frame;
  static const Frame BASE_LINK =
    DirectControlCommand_Frame_BASE_LINK;
  static const Frame ODOM =
    DirectControlCommand_Frame_ODOM;
  static const Frame WORLD =
    DirectControlCommand_Frame_WORLD;
  static const Frame USBL =
    DirectControlCommand_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return DirectControlCommand_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    DirectControlCommand_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    DirectControlCommand_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    DirectControlCommand_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return DirectControlCommand_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return DirectControlCommand_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return DirectControlCommand_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .DirectControlCommand.Frame frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::DirectControlCommand_Frame frame() const;
  void set_frame(::DirectControlCommand_Frame value);

  // required float x = 5 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 5;
  float x() const;
  void set_x(float value);

  // required float y = 6 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 6;
  float y() const;
  void set_y(float value);

  // required float z = 7 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z() const;
  void set_z(float value);

  // required float roll = 8 [(.dccl.field) = {
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 8;
  float roll() const;
  void set_roll(float value);

  // required float pitch = 9 [(.dccl.field) = {
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 9;
  float pitch() const;
  void set_pitch(float value);

  // required float yaw = 10 [(.dccl.field) = {
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 10;
  float yaw() const;
  void set_yaw(float value);

  // required float u = 11 [(.dccl.field) = {
  bool has_u() const;
  void clear_u();
  static const int kUFieldNumber = 11;
  float u() const;
  void set_u(float value);

  // required float v = 12 [(.dccl.field) = {
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 12;
  float v() const;
  void set_v(float value);

  // required float w = 13 [(.dccl.field) = {
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 13;
  float w() const;
  void set_w(float value);

  // required float p = 14 [(.dccl.field) = {
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 14;
  float p() const;
  void set_p(float value);

  // required float q = 15 [(.dccl.field) = {
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 15;
  float q() const;
  void set_q(float value);

  // required float r = 16 [(.dccl.field) = {
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 16;
  float r() const;
  void set_r(float value);

  // @@protoc_insertion_point(class_scope:DirectControlCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_frame();
  void clear_has_frame();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_roll();
  void clear_has_roll();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_u();
  void clear_has_u();
  void set_has_v();
  void clear_has_v();
  void set_has_w();
  void clear_has_w();
  void set_has_p();
  void clear_has_p();
  void set_has_q();
  void clear_has_q();
  void set_has_r();
  void clear_has_r();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int frame_;
  float x_;
  float y_;
  float z_;
  float roll_;
  float pitch_;
  float yaw_;
  float u_;
  float v_;
  float w_;
  float p_;
  float q_;
  float r_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StateCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StateCommand) */ {
 public:
  StateCommand();
  virtual ~StateCommand();

  StateCommand(const StateCommand& from);

  inline StateCommand& operator=(const StateCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StateCommand(StateCommand&& from) noexcept
    : StateCommand() {
    *this = ::std::move(from);
  }

  inline StateCommand& operator=(StateCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateCommand* internal_default_instance() {
    return reinterpret_cast<const StateCommand*>(
               &_StateCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(StateCommand* other);
  friend void swap(StateCommand& a, StateCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StateCommand* New() const final {
    return CreateMaybeMessage<StateCommand>(NULL);
  }

  StateCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StateCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StateCommand& from);
  void MergeFrom(const StateCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StateCommand_Mode Mode;
  static const Mode QUERY =
    StateCommand_Mode_QUERY;
  static const Mode COMMAND =
    StateCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return StateCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    StateCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    StateCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    StateCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return StateCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return StateCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return StateCommand_Mode_Parse(name, value);
  }

  typedef StateCommand_State State;
  static const State KILL =
    StateCommand_State_KILL;
  static const State START =
    StateCommand_State_START;
  static const State SURVEY_LOCAL =
    StateCommand_State_SURVEY_LOCAL;
  static const State SURVEY_GLOBAL =
    StateCommand_State_SURVEY_GLOBAL;
  static const State DIRECT_CONTROL =
    StateCommand_State_DIRECT_CONTROL;
  static const State SURVEY_3D =
    StateCommand_State_SURVEY_3D;
  static inline bool State_IsValid(int value) {
    return StateCommand_State_IsValid(value);
  }
  static const State State_MIN =
    StateCommand_State_State_MIN;
  static const State State_MAX =
    StateCommand_State_State_MAX;
  static const int State_ARRAYSIZE =
    StateCommand_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return StateCommand_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return StateCommand_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return StateCommand_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .StateCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::StateCommand_Mode mode() const;
  void set_mode(::StateCommand_Mode value);

  // optional .StateCommand.State state = 5 [(.dccl.field) = {
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::StateCommand_State state() const;
  void set_state(::StateCommand_State value);

  // @@protoc_insertion_point(class_scope:StateCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  int state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StateResponse) */ {
 public:
  StateResponse();
  virtual ~StateResponse();

  StateResponse(const StateResponse& from);

  inline StateResponse& operator=(const StateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StateResponse(StateResponse&& from) noexcept
    : StateResponse() {
    *this = ::std::move(from);
  }

  inline StateResponse& operator=(StateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateResponse* internal_default_instance() {
    return reinterpret_cast<const StateResponse*>(
               &_StateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(StateResponse* other);
  friend void swap(StateResponse& a, StateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StateResponse* New() const final {
    return CreateMaybeMessage<StateResponse>(NULL);
  }

  StateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StateResponse& from);
  void MergeFrom(const StateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StateResponse_State State;
  static const State KILL =
    StateResponse_State_KILL;
  static const State START =
    StateResponse_State_START;
  static const State SURVEY_LOCAL =
    StateResponse_State_SURVEY_LOCAL;
  static const State SURVEY_GLOBAL =
    StateResponse_State_SURVEY_GLOBAL;
  static const State DIRECT_CONTROL =
    StateResponse_State_DIRECT_CONTROL;
  static const State SURVEY_3D =
    StateResponse_State_SURVEY_3D;
  static inline bool State_IsValid(int value) {
    return StateResponse_State_IsValid(value);
  }
  static const State State_MIN =
    StateResponse_State_State_MIN;
  static const State State_MAX =
    StateResponse_State_State_MAX;
  static const int State_ARRAYSIZE =
    StateResponse_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return StateResponse_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return StateResponse_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return StateResponse_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .StateResponse.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::StateResponse_State state() const;
  void set_state(::StateResponse_State value);

  // @@protoc_insertion_point(class_scope:StateResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int state_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SingleWaypointCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SingleWaypointCommand) */ {
 public:
  SingleWaypointCommand();
  virtual ~SingleWaypointCommand();

  SingleWaypointCommand(const SingleWaypointCommand& from);

  inline SingleWaypointCommand& operator=(const SingleWaypointCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SingleWaypointCommand(SingleWaypointCommand&& from) noexcept
    : SingleWaypointCommand() {
    *this = ::std::move(from);
  }

  inline SingleWaypointCommand& operator=(SingleWaypointCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleWaypointCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleWaypointCommand* internal_default_instance() {
    return reinterpret_cast<const SingleWaypointCommand*>(
               &_SingleWaypointCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SingleWaypointCommand* other);
  friend void swap(SingleWaypointCommand& a, SingleWaypointCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SingleWaypointCommand* New() const final {
    return CreateMaybeMessage<SingleWaypointCommand>(NULL);
  }

  SingleWaypointCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SingleWaypointCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SingleWaypointCommand& from);
  void MergeFrom(const SingleWaypointCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleWaypointCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SingleWaypointCommand_Mode Mode;
  static const Mode QUERY =
    SingleWaypointCommand_Mode_QUERY;
  static const Mode COMMAND_LATLONG =
    SingleWaypointCommand_Mode_COMMAND_LATLONG;
  static const Mode COMMAND_XYZ =
    SingleWaypointCommand_Mode_COMMAND_XYZ;
  static inline bool Mode_IsValid(int value) {
    return SingleWaypointCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    SingleWaypointCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    SingleWaypointCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    SingleWaypointCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return SingleWaypointCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return SingleWaypointCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return SingleWaypointCommand_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional double latitude = 5 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  double latitude() const;
  void set_latitude(double value);

  // required .SingleWaypointCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::SingleWaypointCommand_Mode mode() const;
  void set_mode(::SingleWaypointCommand_Mode value);

  // optional float x = 7 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 7;
  float x() const;
  void set_x(float value);

  // optional double longitude = 6 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  double longitude() const;
  void set_longitude(double value);

  // optional float y = 8 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 8;
  float y() const;
  void set_y(float value);

  // optional float z = 9 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 9;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:SingleWaypointCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  double latitude_;
  int mode_;
  float x_;
  double longitude_;
  float y_;
  float z_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SingleWaypointResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SingleWaypointResponse) */ {
 public:
  SingleWaypointResponse();
  virtual ~SingleWaypointResponse();

  SingleWaypointResponse(const SingleWaypointResponse& from);

  inline SingleWaypointResponse& operator=(const SingleWaypointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SingleWaypointResponse(SingleWaypointResponse&& from) noexcept
    : SingleWaypointResponse() {
    *this = ::std::move(from);
  }

  inline SingleWaypointResponse& operator=(SingleWaypointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleWaypointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleWaypointResponse* internal_default_instance() {
    return reinterpret_cast<const SingleWaypointResponse*>(
               &_SingleWaypointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SingleWaypointResponse* other);
  friend void swap(SingleWaypointResponse& a, SingleWaypointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SingleWaypointResponse* New() const final {
    return CreateMaybeMessage<SingleWaypointResponse>(NULL);
  }

  SingleWaypointResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SingleWaypointResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SingleWaypointResponse& from);
  void MergeFrom(const SingleWaypointResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleWaypointResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required double latitude = 4 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 5 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // required float x = 6 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 6;
  float x() const;
  void set_x(float value);

  // required float y = 7 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 7;
  float y() const;
  void set_y(float value);

  // required float z = 8 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:SingleWaypointResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  double latitude_;
  double longitude_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointGPSCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointGPSCommand) */ {
 public:
  MultiWaypointGPSCommand();
  virtual ~MultiWaypointGPSCommand();

  MultiWaypointGPSCommand(const MultiWaypointGPSCommand& from);

  inline MultiWaypointGPSCommand& operator=(const MultiWaypointGPSCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointGPSCommand(MultiWaypointGPSCommand&& from) noexcept
    : MultiWaypointGPSCommand() {
    *this = ::std::move(from);
  }

  inline MultiWaypointGPSCommand& operator=(MultiWaypointGPSCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointGPSCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointGPSCommand* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointGPSCommand*>(
               &_MultiWaypointGPSCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MultiWaypointGPSCommand* other);
  friend void swap(MultiWaypointGPSCommand& a, MultiWaypointGPSCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointGPSCommand* New() const final {
    return CreateMaybeMessage<MultiWaypointGPSCommand>(NULL);
  }

  MultiWaypointGPSCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointGPSCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointGPSCommand& from);
  void MergeFrom(const MultiWaypointGPSCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointGPSCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiWaypointGPSCommand_Mode Mode;
  static const Mode QUERY =
    MultiWaypointGPSCommand_Mode_QUERY;
  static const Mode COMMAND =
    MultiWaypointGPSCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return MultiWaypointGPSCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MultiWaypointGPSCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MultiWaypointGPSCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MultiWaypointGPSCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MultiWaypointGPSCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MultiWaypointGPSCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MultiWaypointGPSCommand_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 5 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 5;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated double latitude = 6 [(.dccl.field) = {
  int latitude_size() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  double latitude(int index) const;
  void set_latitude(int index, double value);
  void add_latitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      latitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_latitude();

  // repeated double longitude = 7 [(.dccl.field) = {
  int longitude_size() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 7;
  double longitude(int index) const;
  void set_longitude(int index, double value);
  void add_longitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      longitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_longitude();

  // repeated float z = 8 [(.dccl.field) = {
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .MultiWaypointGPSCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::MultiWaypointGPSCommand_Mode mode() const;
  void set_mode(::MultiWaypointGPSCommand_Mode value);

  // optional bool end = 9 [(.dccl.field) = {
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 9;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointGPSCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< double > latitude_;
  ::google::protobuf::RepeatedField< double > longitude_;
  ::google::protobuf::RepeatedField< float > z_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointGPSResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointGPSResponse) */ {
 public:
  MultiWaypointGPSResponse();
  virtual ~MultiWaypointGPSResponse();

  MultiWaypointGPSResponse(const MultiWaypointGPSResponse& from);

  inline MultiWaypointGPSResponse& operator=(const MultiWaypointGPSResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointGPSResponse(MultiWaypointGPSResponse&& from) noexcept
    : MultiWaypointGPSResponse() {
    *this = ::std::move(from);
  }

  inline MultiWaypointGPSResponse& operator=(MultiWaypointGPSResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointGPSResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointGPSResponse* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointGPSResponse*>(
               &_MultiWaypointGPSResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MultiWaypointGPSResponse* other);
  friend void swap(MultiWaypointGPSResponse& a, MultiWaypointGPSResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointGPSResponse* New() const final {
    return CreateMaybeMessage<MultiWaypointGPSResponse>(NULL);
  }

  MultiWaypointGPSResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointGPSResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointGPSResponse& from);
  void MergeFrom(const MultiWaypointGPSResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointGPSResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiWaypointGPSResponse_Mode Mode;
  static const Mode QUERY =
    MultiWaypointGPSResponse_Mode_QUERY;
  static const Mode COMMAND =
    MultiWaypointGPSResponse_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return MultiWaypointGPSResponse_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MultiWaypointGPSResponse_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MultiWaypointGPSResponse_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MultiWaypointGPSResponse_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MultiWaypointGPSResponse_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MultiWaypointGPSResponse_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MultiWaypointGPSResponse_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated double latitude = 5 [(.dccl.field) = {
  int latitude_size() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  double latitude(int index) const;
  void set_latitude(int index, double value);
  void add_latitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      latitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_latitude();

  // repeated double longitude = 6 [(.dccl.field) = {
  int longitude_size() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  double longitude(int index) const;
  void set_longitude(int index, double value);
  void add_longitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      longitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_longitude();

  // repeated float z = 7 [(.dccl.field) = {
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required int32 wpt_num = 4 [(.dccl.field) = {
  bool has_wpt_num() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 4;
  ::google::protobuf::int32 wpt_num() const;
  void set_wpt_num(::google::protobuf::int32 value);

  // optional bool end = 8;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 8;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointGPSResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_wpt_num();
  void clear_has_wpt_num();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > latitude_;
  ::google::protobuf::RepeatedField< double > longitude_;
  ::google::protobuf::RepeatedField< float > z_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  ::google::protobuf::int32 wpt_num_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointXYZCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointXYZCommand) */ {
 public:
  MultiWaypointXYZCommand();
  virtual ~MultiWaypointXYZCommand();

  MultiWaypointXYZCommand(const MultiWaypointXYZCommand& from);

  inline MultiWaypointXYZCommand& operator=(const MultiWaypointXYZCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointXYZCommand(MultiWaypointXYZCommand&& from) noexcept
    : MultiWaypointXYZCommand() {
    *this = ::std::move(from);
  }

  inline MultiWaypointXYZCommand& operator=(MultiWaypointXYZCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointXYZCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointXYZCommand* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointXYZCommand*>(
               &_MultiWaypointXYZCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MultiWaypointXYZCommand* other);
  friend void swap(MultiWaypointXYZCommand& a, MultiWaypointXYZCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointXYZCommand* New() const final {
    return CreateMaybeMessage<MultiWaypointXYZCommand>(NULL);
  }

  MultiWaypointXYZCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointXYZCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointXYZCommand& from);
  void MergeFrom(const MultiWaypointXYZCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointXYZCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiWaypointXYZCommand_Mode Mode;
  static const Mode QUERY =
    MultiWaypointXYZCommand_Mode_QUERY;
  static const Mode COMMAND =
    MultiWaypointXYZCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return MultiWaypointXYZCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MultiWaypointXYZCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MultiWaypointXYZCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MultiWaypointXYZCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MultiWaypointXYZCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MultiWaypointXYZCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MultiWaypointXYZCommand_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 5 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 5;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated float x = 6 [(.dccl.field) = {
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 6;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .MultiWaypointXYZCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::MultiWaypointXYZCommand_Mode mode() const;
  void set_mode(::MultiWaypointXYZCommand_Mode value);

  // required float y = 7 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 7;
  float y() const;
  void set_y(float value);

  // required float z = 8 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z() const;
  void set_z(float value);

  // required bool end = 9 [(.dccl.field) = {
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 9;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointXYZCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< float > x_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  float y_;
  float z_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointXYZResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointXYZResponse) */ {
 public:
  MultiWaypointXYZResponse();
  virtual ~MultiWaypointXYZResponse();

  MultiWaypointXYZResponse(const MultiWaypointXYZResponse& from);

  inline MultiWaypointXYZResponse& operator=(const MultiWaypointXYZResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointXYZResponse(MultiWaypointXYZResponse&& from) noexcept
    : MultiWaypointXYZResponse() {
    *this = ::std::move(from);
  }

  inline MultiWaypointXYZResponse& operator=(MultiWaypointXYZResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointXYZResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointXYZResponse* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointXYZResponse*>(
               &_MultiWaypointXYZResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MultiWaypointXYZResponse* other);
  friend void swap(MultiWaypointXYZResponse& a, MultiWaypointXYZResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointXYZResponse* New() const final {
    return CreateMaybeMessage<MultiWaypointXYZResponse>(NULL);
  }

  MultiWaypointXYZResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointXYZResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointXYZResponse& from);
  void MergeFrom(const MultiWaypointXYZResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointXYZResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 4 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 4;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated float x = 5 [(.dccl.field) = {
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 5;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required float y = 6 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 6;
  float y() const;
  void set_y(float value);

  // required float z = 7 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z() const;
  void set_z(float value);

  // required bool end = 9;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 9;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointXYZResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< float > x_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  float y_;
  float z_;
  bool end_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteWaypoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExecuteWaypoints) */ {
 public:
  ExecuteWaypoints();
  virtual ~ExecuteWaypoints();

  ExecuteWaypoints(const ExecuteWaypoints& from);

  inline ExecuteWaypoints& operator=(const ExecuteWaypoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteWaypoints(ExecuteWaypoints&& from) noexcept
    : ExecuteWaypoints() {
    *this = ::std::move(from);
  }

  inline ExecuteWaypoints& operator=(ExecuteWaypoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteWaypoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteWaypoints* internal_default_instance() {
    return reinterpret_cast<const ExecuteWaypoints*>(
               &_ExecuteWaypoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ExecuteWaypoints* other);
  friend void swap(ExecuteWaypoints& a, ExecuteWaypoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteWaypoints* New() const final {
    return CreateMaybeMessage<ExecuteWaypoints>(NULL);
  }

  ExecuteWaypoints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteWaypoints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteWaypoints& from);
  void MergeFrom(const ExecuteWaypoints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteWaypoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteWaypoints_WaypointMode WaypointMode;
  static const WaypointMode APPEND =
    ExecuteWaypoints_WaypointMode_APPEND;
  static const WaypointMode UPDATE =
    ExecuteWaypoints_WaypointMode_UPDATE;
  static inline bool WaypointMode_IsValid(int value) {
    return ExecuteWaypoints_WaypointMode_IsValid(value);
  }
  static const WaypointMode WaypointMode_MIN =
    ExecuteWaypoints_WaypointMode_WaypointMode_MIN;
  static const WaypointMode WaypointMode_MAX =
    ExecuteWaypoints_WaypointMode_WaypointMode_MAX;
  static const int WaypointMode_ARRAYSIZE =
    ExecuteWaypoints_WaypointMode_WaypointMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WaypointMode_descriptor() {
    return ExecuteWaypoints_WaypointMode_descriptor();
  }
  static inline const ::std::string& WaypointMode_Name(WaypointMode value) {
    return ExecuteWaypoints_WaypointMode_Name(value);
  }
  static inline bool WaypointMode_Parse(const ::std::string& name,
      WaypointMode* value) {
    return ExecuteWaypoints_WaypointMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required bool execute = 4;
  bool has_execute() const;
  void clear_execute();
  static const int kExecuteFieldNumber = 4;
  bool execute() const;
  void set_execute(bool value);

  // required .ExecuteWaypoints.WaypointMode mode = 5;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  ::ExecuteWaypoints_WaypointMode mode() const;
  void set_mode(::ExecuteWaypoints_WaypointMode value);

  // @@protoc_insertion_point(class_scope:ExecuteWaypoints)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_execute();
  void clear_has_execute();
  void set_has_mode();
  void clear_has_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  bool execute_;
  int mode_;
  friend struct ::protobuf_goby_5fmsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PoseCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool PoseCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PoseCommand::source() const {
  // @@protoc_insertion_point(field_get:PoseCommand.source)
  return source_;
}
inline void PoseCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PoseCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PoseCommand::destination() const {
  // @@protoc_insertion_point(field_get:PoseCommand.destination)
  return destination_;
}
inline void PoseCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool PoseCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoseCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoseCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoseCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PoseCommand::time() const {
  // @@protoc_insertion_point(field_get:PoseCommand.time)
  return time_;
}
inline void PoseCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.time)
}

// -------------------------------------------------------------------

// PoseResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool PoseResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PoseResponse::source() const {
  // @@protoc_insertion_point(field_get:PoseResponse.source)
  return source_;
}
inline void PoseResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PoseResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PoseResponse::destination() const {
  // @@protoc_insertion_point(field_get:PoseResponse.destination)
  return destination_;
}
inline void PoseResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.destination)
}

// required double time = 3 [(.dccl.field) = {
inline bool PoseResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoseResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoseResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoseResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PoseResponse::time() const {
  // @@protoc_insertion_point(field_get:PoseResponse.time)
  return time_;
}
inline void PoseResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.time)
}

// required double latitude = 4 [(.dccl.field) = {
inline bool PoseResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoseResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoseResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoseResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double PoseResponse::latitude() const {
  // @@protoc_insertion_point(field_get:PoseResponse.latitude)
  return latitude_;
}
inline void PoseResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.latitude)
}

// required double longitude = 5 [(.dccl.field) = {
inline bool PoseResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoseResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoseResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoseResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double PoseResponse::longitude() const {
  // @@protoc_insertion_point(field_get:PoseResponse.longitude)
  return longitude_;
}
inline void PoseResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.longitude)
}

// required float x = 6 [(.dccl.field) = {
inline bool PoseResponse::has_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PoseResponse::set_has_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PoseResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PoseResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PoseResponse::x() const {
  // @@protoc_insertion_point(field_get:PoseResponse.x)
  return x_;
}
inline void PoseResponse::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.x)
}

// required float y = 7 [(.dccl.field) = {
inline bool PoseResponse::has_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PoseResponse::set_has_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PoseResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PoseResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PoseResponse::y() const {
  // @@protoc_insertion_point(field_get:PoseResponse.y)
  return y_;
}
inline void PoseResponse::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.y)
}

// required float z = 8 [(.dccl.field) = {
inline bool PoseResponse::has_z() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PoseResponse::set_has_z() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PoseResponse::clear_has_z() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PoseResponse::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PoseResponse::z() const {
  // @@protoc_insertion_point(field_get:PoseResponse.z)
  return z_;
}
inline void PoseResponse::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.z)
}

// required float quat_x = 9 [(.dccl.field) = {
inline bool PoseResponse::has_quat_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PoseResponse::set_has_quat_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PoseResponse::clear_has_quat_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PoseResponse::clear_quat_x() {
  quat_x_ = 0;
  clear_has_quat_x();
}
inline float PoseResponse::quat_x() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_x)
  return quat_x_;
}
inline void PoseResponse::set_quat_x(float value) {
  set_has_quat_x();
  quat_x_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_x)
}

// required float quat_y = 10 [(.dccl.field) = {
inline bool PoseResponse::has_quat_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PoseResponse::set_has_quat_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PoseResponse::clear_has_quat_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PoseResponse::clear_quat_y() {
  quat_y_ = 0;
  clear_has_quat_y();
}
inline float PoseResponse::quat_y() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_y)
  return quat_y_;
}
inline void PoseResponse::set_quat_y(float value) {
  set_has_quat_y();
  quat_y_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_y)
}

// required float quat_z = 11 [(.dccl.field) = {
inline bool PoseResponse::has_quat_z() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PoseResponse::set_has_quat_z() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PoseResponse::clear_has_quat_z() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PoseResponse::clear_quat_z() {
  quat_z_ = 0;
  clear_has_quat_z();
}
inline float PoseResponse::quat_z() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_z)
  return quat_z_;
}
inline void PoseResponse::set_quat_z(float value) {
  set_has_quat_z();
  quat_z_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_z)
}

// required float quat_w = 12 [(.dccl.field) = {
inline bool PoseResponse::has_quat_w() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PoseResponse::set_has_quat_w() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PoseResponse::clear_has_quat_w() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PoseResponse::clear_quat_w() {
  quat_w_ = 0;
  clear_has_quat_w();
}
inline float PoseResponse::quat_w() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_w)
  return quat_w_;
}
inline void PoseResponse::set_quat_w(float value) {
  set_has_quat_w();
  quat_w_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_w)
}

// -------------------------------------------------------------------

// HealthCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool HealthCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 HealthCommand::source() const {
  // @@protoc_insertion_point(field_get:HealthCommand.source)
  return source_;
}
inline void HealthCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:HealthCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool HealthCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 HealthCommand::destination() const {
  // @@protoc_insertion_point(field_get:HealthCommand.destination)
  return destination_;
}
inline void HealthCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:HealthCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool HealthCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double HealthCommand::time() const {
  // @@protoc_insertion_point(field_get:HealthCommand.time)
  return time_;
}
inline void HealthCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:HealthCommand.time)
}

// -------------------------------------------------------------------

// HealthResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool HealthResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 HealthResponse::source() const {
  // @@protoc_insertion_point(field_get:HealthResponse.source)
  return source_;
}
inline void HealthResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:HealthResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool HealthResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 HealthResponse::destination() const {
  // @@protoc_insertion_point(field_get:HealthResponse.destination)
  return destination_;
}
inline void HealthResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:HealthResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool HealthResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double HealthResponse::time() const {
  // @@protoc_insertion_point(field_get:HealthResponse.time)
  return time_;
}
inline void HealthResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:HealthResponse.time)
}

// required float batt_volt = 4 [(.dccl.field) = {
inline bool HealthResponse::has_batt_volt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthResponse::set_has_batt_volt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthResponse::clear_has_batt_volt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthResponse::clear_batt_volt() {
  batt_volt_ = 0;
  clear_has_batt_volt();
}
inline float HealthResponse::batt_volt() const {
  // @@protoc_insertion_point(field_get:HealthResponse.batt_volt)
  return batt_volt_;
}
inline void HealthResponse::set_batt_volt(float value) {
  set_has_batt_volt();
  batt_volt_ = value;
  // @@protoc_insertion_point(field_set:HealthResponse.batt_volt)
}

// required float current = 5 [(.dccl.field) = {
inline bool HealthResponse::has_current() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthResponse::set_has_current() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthResponse::clear_has_current() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthResponse::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float HealthResponse::current() const {
  // @@protoc_insertion_point(field_get:HealthResponse.current)
  return current_;
}
inline void HealthResponse::set_current(float value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:HealthResponse.current)
}

// -------------------------------------------------------------------

// RelativePoseCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool RelativePoseCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePoseCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePoseCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePoseCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 RelativePoseCommand::source() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.source)
  return source_;
}
inline void RelativePoseCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool RelativePoseCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePoseCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePoseCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePoseCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 RelativePoseCommand::destination() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.destination)
  return destination_;
}
inline void RelativePoseCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool RelativePoseCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePoseCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePoseCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePoseCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double RelativePoseCommand::time() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.time)
  return time_;
}
inline void RelativePoseCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.time)
}

// required .RelativePoseCommand.Frame parent = 4;
inline bool RelativePoseCommand::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePoseCommand::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePoseCommand::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePoseCommand::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::RelativePoseCommand_Frame RelativePoseCommand::parent() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.parent)
  return static_cast< ::RelativePoseCommand_Frame >(parent_);
}
inline void RelativePoseCommand::set_parent(::RelativePoseCommand_Frame value) {
  assert(::RelativePoseCommand_Frame_IsValid(value));
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.parent)
}

// required .RelativePoseCommand.Frame child = 5;
inline bool RelativePoseCommand::has_child() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePoseCommand::set_has_child() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePoseCommand::clear_has_child() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePoseCommand::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::RelativePoseCommand_Frame RelativePoseCommand::child() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.child)
  return static_cast< ::RelativePoseCommand_Frame >(child_);
}
inline void RelativePoseCommand::set_child(::RelativePoseCommand_Frame value) {
  assert(::RelativePoseCommand_Frame_IsValid(value));
  set_has_child();
  child_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.child)
}

// -------------------------------------------------------------------

// RelativePoseResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool RelativePoseResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePoseResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePoseResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePoseResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 RelativePoseResponse::source() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.source)
  return source_;
}
inline void RelativePoseResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool RelativePoseResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePoseResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePoseResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePoseResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 RelativePoseResponse::destination() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.destination)
  return destination_;
}
inline void RelativePoseResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool RelativePoseResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePoseResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePoseResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePoseResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double RelativePoseResponse::time() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.time)
  return time_;
}
inline void RelativePoseResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.time)
}

// required .RelativePoseResponse.Frame parent = 4;
inline bool RelativePoseResponse::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePoseResponse::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePoseResponse::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePoseResponse::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::RelativePoseResponse_Frame RelativePoseResponse::parent() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.parent)
  return static_cast< ::RelativePoseResponse_Frame >(parent_);
}
inline void RelativePoseResponse::set_parent(::RelativePoseResponse_Frame value) {
  assert(::RelativePoseResponse_Frame_IsValid(value));
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.parent)
}

// required .RelativePoseResponse.Frame child = 5;
inline bool RelativePoseResponse::has_child() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePoseResponse::set_has_child() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePoseResponse::clear_has_child() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePoseResponse::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::RelativePoseResponse_Frame RelativePoseResponse::child() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.child)
  return static_cast< ::RelativePoseResponse_Frame >(child_);
}
inline void RelativePoseResponse::set_child(::RelativePoseResponse_Frame value) {
  assert(::RelativePoseResponse_Frame_IsValid(value));
  set_has_child();
  child_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.child)
}

// required double latitude = 6 [(.dccl.field) = {
inline bool RelativePoseResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RelativePoseResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RelativePoseResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RelativePoseResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double RelativePoseResponse::latitude() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.latitude)
  return latitude_;
}
inline void RelativePoseResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.latitude)
}

// required double longitude = 7 [(.dccl.field) = {
inline bool RelativePoseResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RelativePoseResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RelativePoseResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RelativePoseResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double RelativePoseResponse::longitude() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.longitude)
  return longitude_;
}
inline void RelativePoseResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.longitude)
}

// required float x = 8 [(.dccl.field) = {
inline bool RelativePoseResponse::has_x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RelativePoseResponse::set_has_x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RelativePoseResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RelativePoseResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float RelativePoseResponse::x() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.x)
  return x_;
}
inline void RelativePoseResponse::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.x)
}

// required float y = 9 [(.dccl.field) = {
inline bool RelativePoseResponse::has_y() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RelativePoseResponse::set_has_y() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RelativePoseResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RelativePoseResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float RelativePoseResponse::y() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.y)
  return y_;
}
inline void RelativePoseResponse::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.y)
}

// required float z = 10 [(.dccl.field) = {
inline bool RelativePoseResponse::has_z() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RelativePoseResponse::set_has_z() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RelativePoseResponse::clear_has_z() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RelativePoseResponse::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float RelativePoseResponse::z() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.z)
  return z_;
}
inline void RelativePoseResponse::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.z)
}

// required float quat_x = 11 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RelativePoseResponse::set_has_quat_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RelativePoseResponse::clear_has_quat_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RelativePoseResponse::clear_quat_x() {
  quat_x_ = 0;
  clear_has_quat_x();
}
inline float RelativePoseResponse::quat_x() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_x)
  return quat_x_;
}
inline void RelativePoseResponse::set_quat_x(float value) {
  set_has_quat_x();
  quat_x_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_x)
}

// required float quat_y = 12 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RelativePoseResponse::set_has_quat_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RelativePoseResponse::clear_has_quat_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RelativePoseResponse::clear_quat_y() {
  quat_y_ = 0;
  clear_has_quat_y();
}
inline float RelativePoseResponse::quat_y() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_y)
  return quat_y_;
}
inline void RelativePoseResponse::set_quat_y(float value) {
  set_has_quat_y();
  quat_y_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_y)
}

// required float quat_z = 13 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_z() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RelativePoseResponse::set_has_quat_z() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RelativePoseResponse::clear_has_quat_z() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RelativePoseResponse::clear_quat_z() {
  quat_z_ = 0;
  clear_has_quat_z();
}
inline float RelativePoseResponse::quat_z() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_z)
  return quat_z_;
}
inline void RelativePoseResponse::set_quat_z(float value) {
  set_has_quat_z();
  quat_z_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_z)
}

// required float quat_w = 14 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_w() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RelativePoseResponse::set_has_quat_w() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RelativePoseResponse::clear_has_quat_w() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RelativePoseResponse::clear_quat_w() {
  quat_w_ = 0;
  clear_has_quat_w();
}
inline float RelativePoseResponse::quat_w() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_w)
  return quat_w_;
}
inline void RelativePoseResponse::set_quat_w(float value) {
  set_has_quat_w();
  quat_w_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_w)
}

// -------------------------------------------------------------------

// ControllerStateCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool ControllerStateCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerStateCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerStateCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerStateCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ControllerStateCommand::source() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.source)
  return source_;
}
inline void ControllerStateCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ControllerStateCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerStateCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerStateCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerStateCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ControllerStateCommand::destination() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.destination)
  return destination_;
}
inline void ControllerStateCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ControllerStateCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerStateCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerStateCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerStateCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ControllerStateCommand::time() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.time)
  return time_;
}
inline void ControllerStateCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.time)
}

// required .ControllerStateCommand.State state = 4;
inline bool ControllerStateCommand::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerStateCommand::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerStateCommand::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerStateCommand::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::ControllerStateCommand_State ControllerStateCommand::state() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.state)
  return static_cast< ::ControllerStateCommand_State >(state_);
}
inline void ControllerStateCommand::set_state(::ControllerStateCommand_State value) {
  assert(::ControllerStateCommand_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.state)
}

// -------------------------------------------------------------------

// ControllerStateResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool ControllerStateResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerStateResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerStateResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerStateResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ControllerStateResponse::source() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.source)
  return source_;
}
inline void ControllerStateResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ControllerStateResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerStateResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerStateResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerStateResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ControllerStateResponse::destination() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.destination)
  return destination_;
}
inline void ControllerStateResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ControllerStateResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerStateResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerStateResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerStateResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ControllerStateResponse::time() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.time)
  return time_;
}
inline void ControllerStateResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.time)
}

// required .ControllerStateResponse.State state = 4;
inline bool ControllerStateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerStateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerStateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerStateResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::ControllerStateResponse_State ControllerStateResponse::state() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.state)
  return static_cast< ::ControllerStateResponse_State >(state_);
}
inline void ControllerStateResponse::set_state(::ControllerStateResponse_State value) {
  assert(::ControllerStateResponse_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.state)
}

// -------------------------------------------------------------------

// DirectControlCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool DirectControlCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectControlCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectControlCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectControlCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 DirectControlCommand::source() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.source)
  return source_;
}
inline void DirectControlCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool DirectControlCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectControlCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectControlCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectControlCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 DirectControlCommand::destination() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.destination)
  return destination_;
}
inline void DirectControlCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool DirectControlCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectControlCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectControlCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectControlCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double DirectControlCommand::time() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.time)
  return time_;
}
inline void DirectControlCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.time)
}

// required .DirectControlCommand.Frame frame = 4;
inline bool DirectControlCommand::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectControlCommand::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectControlCommand::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectControlCommand::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::DirectControlCommand_Frame DirectControlCommand::frame() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.frame)
  return static_cast< ::DirectControlCommand_Frame >(frame_);
}
inline void DirectControlCommand::set_frame(::DirectControlCommand_Frame value) {
  assert(::DirectControlCommand_Frame_IsValid(value));
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.frame)
}

// required float x = 5 [(.dccl.field) = {
inline bool DirectControlCommand::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectControlCommand::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectControlCommand::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectControlCommand::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float DirectControlCommand::x() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.x)
  return x_;
}
inline void DirectControlCommand::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.x)
}

// required float y = 6 [(.dccl.field) = {
inline bool DirectControlCommand::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectControlCommand::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectControlCommand::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectControlCommand::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float DirectControlCommand::y() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.y)
  return y_;
}
inline void DirectControlCommand::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.y)
}

// required float z = 7 [(.dccl.field) = {
inline bool DirectControlCommand::has_z() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectControlCommand::set_has_z() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectControlCommand::clear_has_z() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectControlCommand::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float DirectControlCommand::z() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.z)
  return z_;
}
inline void DirectControlCommand::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.z)
}

// required float roll = 8 [(.dccl.field) = {
inline bool DirectControlCommand::has_roll() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectControlCommand::set_has_roll() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectControlCommand::clear_has_roll() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectControlCommand::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float DirectControlCommand::roll() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.roll)
  return roll_;
}
inline void DirectControlCommand::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.roll)
}

// required float pitch = 9 [(.dccl.field) = {
inline bool DirectControlCommand::has_pitch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectControlCommand::set_has_pitch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectControlCommand::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectControlCommand::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float DirectControlCommand::pitch() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.pitch)
  return pitch_;
}
inline void DirectControlCommand::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.pitch)
}

// required float yaw = 10 [(.dccl.field) = {
inline bool DirectControlCommand::has_yaw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectControlCommand::set_has_yaw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectControlCommand::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectControlCommand::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float DirectControlCommand::yaw() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.yaw)
  return yaw_;
}
inline void DirectControlCommand::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.yaw)
}

// required float u = 11 [(.dccl.field) = {
inline bool DirectControlCommand::has_u() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DirectControlCommand::set_has_u() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DirectControlCommand::clear_has_u() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DirectControlCommand::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline float DirectControlCommand::u() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.u)
  return u_;
}
inline void DirectControlCommand::set_u(float value) {
  set_has_u();
  u_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.u)
}

// required float v = 12 [(.dccl.field) = {
inline bool DirectControlCommand::has_v() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DirectControlCommand::set_has_v() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DirectControlCommand::clear_has_v() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DirectControlCommand::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline float DirectControlCommand::v() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.v)
  return v_;
}
inline void DirectControlCommand::set_v(float value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.v)
}

// required float w = 13 [(.dccl.field) = {
inline bool DirectControlCommand::has_w() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DirectControlCommand::set_has_w() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DirectControlCommand::clear_has_w() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DirectControlCommand::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float DirectControlCommand::w() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.w)
  return w_;
}
inline void DirectControlCommand::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.w)
}

// required float p = 14 [(.dccl.field) = {
inline bool DirectControlCommand::has_p() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DirectControlCommand::set_has_p() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DirectControlCommand::clear_has_p() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DirectControlCommand::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float DirectControlCommand::p() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.p)
  return p_;
}
inline void DirectControlCommand::set_p(float value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.p)
}

// required float q = 15 [(.dccl.field) = {
inline bool DirectControlCommand::has_q() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DirectControlCommand::set_has_q() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DirectControlCommand::clear_has_q() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DirectControlCommand::clear_q() {
  q_ = 0;
  clear_has_q();
}
inline float DirectControlCommand::q() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.q)
  return q_;
}
inline void DirectControlCommand::set_q(float value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.q)
}

// required float r = 16 [(.dccl.field) = {
inline bool DirectControlCommand::has_r() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DirectControlCommand::set_has_r() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DirectControlCommand::clear_has_r() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DirectControlCommand::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float DirectControlCommand::r() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.r)
  return r_;
}
inline void DirectControlCommand::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.r)
}

// -------------------------------------------------------------------

// StateCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool StateCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 StateCommand::source() const {
  // @@protoc_insertion_point(field_get:StateCommand.source)
  return source_;
}
inline void StateCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:StateCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool StateCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 StateCommand::destination() const {
  // @@protoc_insertion_point(field_get:StateCommand.destination)
  return destination_;
}
inline void StateCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:StateCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool StateCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double StateCommand::time() const {
  // @@protoc_insertion_point(field_get:StateCommand.time)
  return time_;
}
inline void StateCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:StateCommand.time)
}

// required .StateCommand.Mode mode = 4;
inline bool StateCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StateCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::StateCommand_Mode StateCommand::mode() const {
  // @@protoc_insertion_point(field_get:StateCommand.mode)
  return static_cast< ::StateCommand_Mode >(mode_);
}
inline void StateCommand::set_mode(::StateCommand_Mode value) {
  assert(::StateCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:StateCommand.mode)
}

// optional .StateCommand.State state = 5 [(.dccl.field) = {
inline bool StateCommand::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StateCommand::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StateCommand::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StateCommand::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::StateCommand_State StateCommand::state() const {
  // @@protoc_insertion_point(field_get:StateCommand.state)
  return static_cast< ::StateCommand_State >(state_);
}
inline void StateCommand::set_state(::StateCommand_State value) {
  assert(::StateCommand_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:StateCommand.state)
}

// -------------------------------------------------------------------

// StateResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool StateResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 StateResponse::source() const {
  // @@protoc_insertion_point(field_get:StateResponse.source)
  return source_;
}
inline void StateResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:StateResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool StateResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 StateResponse::destination() const {
  // @@protoc_insertion_point(field_get:StateResponse.destination)
  return destination_;
}
inline void StateResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:StateResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool StateResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double StateResponse::time() const {
  // @@protoc_insertion_point(field_get:StateResponse.time)
  return time_;
}
inline void StateResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:StateResponse.time)
}

// required .StateResponse.State state = 4;
inline bool StateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StateResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::StateResponse_State StateResponse::state() const {
  // @@protoc_insertion_point(field_get:StateResponse.state)
  return static_cast< ::StateResponse_State >(state_);
}
inline void StateResponse::set_state(::StateResponse_State value) {
  assert(::StateResponse_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:StateResponse.state)
}

// -------------------------------------------------------------------

// SingleWaypointCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleWaypointCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleWaypointCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleWaypointCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 SingleWaypointCommand::source() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.source)
  return source_;
}
inline void SingleWaypointCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleWaypointCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleWaypointCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleWaypointCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 SingleWaypointCommand::destination() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.destination)
  return destination_;
}
inline void SingleWaypointCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleWaypointCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleWaypointCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleWaypointCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SingleWaypointCommand::time() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.time)
  return time_;
}
inline void SingleWaypointCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.time)
}

// required .SingleWaypointCommand.Mode mode = 4;
inline bool SingleWaypointCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleWaypointCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleWaypointCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleWaypointCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::SingleWaypointCommand_Mode SingleWaypointCommand::mode() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.mode)
  return static_cast< ::SingleWaypointCommand_Mode >(mode_);
}
inline void SingleWaypointCommand::set_mode(::SingleWaypointCommand_Mode value) {
  assert(::SingleWaypointCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.mode)
}

// optional double latitude = 5 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleWaypointCommand::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleWaypointCommand::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleWaypointCommand::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double SingleWaypointCommand::latitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.latitude)
  return latitude_;
}
inline void SingleWaypointCommand::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.latitude)
}

// optional double longitude = 6 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_longitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SingleWaypointCommand::set_has_longitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SingleWaypointCommand::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SingleWaypointCommand::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double SingleWaypointCommand::longitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.longitude)
  return longitude_;
}
inline void SingleWaypointCommand::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.longitude)
}

// optional float x = 7 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleWaypointCommand::set_has_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleWaypointCommand::clear_has_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleWaypointCommand::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float SingleWaypointCommand::x() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.x)
  return x_;
}
inline void SingleWaypointCommand::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.x)
}

// optional float y = 8 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SingleWaypointCommand::set_has_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SingleWaypointCommand::clear_has_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SingleWaypointCommand::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float SingleWaypointCommand::y() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.y)
  return y_;
}
inline void SingleWaypointCommand::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.y)
}

// optional float z = 9 [(.dccl.field) = {
inline bool SingleWaypointCommand::has_z() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SingleWaypointCommand::set_has_z() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SingleWaypointCommand::clear_has_z() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SingleWaypointCommand::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float SingleWaypointCommand::z() const {
  // @@protoc_insertion_point(field_get:SingleWaypointCommand.z)
  return z_;
}
inline void SingleWaypointCommand::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointCommand.z)
}

// -------------------------------------------------------------------

// SingleWaypointResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleWaypointResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleWaypointResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleWaypointResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 SingleWaypointResponse::source() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.source)
  return source_;
}
inline void SingleWaypointResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleWaypointResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleWaypointResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleWaypointResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 SingleWaypointResponse::destination() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.destination)
  return destination_;
}
inline void SingleWaypointResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleWaypointResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleWaypointResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleWaypointResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SingleWaypointResponse::time() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.time)
  return time_;
}
inline void SingleWaypointResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.time)
}

// required double latitude = 4 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleWaypointResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleWaypointResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleWaypointResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double SingleWaypointResponse::latitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.latitude)
  return latitude_;
}
inline void SingleWaypointResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.latitude)
}

// required double longitude = 5 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleWaypointResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleWaypointResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleWaypointResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double SingleWaypointResponse::longitude() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.longitude)
  return longitude_;
}
inline void SingleWaypointResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.longitude)
}

// required float x = 6 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleWaypointResponse::set_has_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleWaypointResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleWaypointResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float SingleWaypointResponse::x() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.x)
  return x_;
}
inline void SingleWaypointResponse::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.x)
}

// required float y = 7 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SingleWaypointResponse::set_has_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SingleWaypointResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SingleWaypointResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float SingleWaypointResponse::y() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.y)
  return y_;
}
inline void SingleWaypointResponse::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.y)
}

// required float z = 8 [(.dccl.field) = {
inline bool SingleWaypointResponse::has_z() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SingleWaypointResponse::set_has_z() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SingleWaypointResponse::clear_has_z() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SingleWaypointResponse::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float SingleWaypointResponse::z() const {
  // @@protoc_insertion_point(field_get:SingleWaypointResponse.z)
  return z_;
}
inline void SingleWaypointResponse::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:SingleWaypointResponse.z)
}

// -------------------------------------------------------------------

// MultiWaypointGPSCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointGPSCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointGPSCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointGPSCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointGPSCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointGPSCommand::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.source)
  return source_;
}
inline void MultiWaypointGPSCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointGPSCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointGPSCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointGPSCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointGPSCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointGPSCommand::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.destination)
  return destination_;
}
inline void MultiWaypointGPSCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool MultiWaypointGPSCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointGPSCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointGPSCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointGPSCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointGPSCommand::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.time)
  return time_;
}
inline void MultiWaypointGPSCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.time)
}

// required .MultiWaypointGPSCommand.Mode mode = 4;
inline bool MultiWaypointGPSCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointGPSCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointGPSCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointGPSCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::MultiWaypointGPSCommand_Mode MultiWaypointGPSCommand::mode() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.mode)
  return static_cast< ::MultiWaypointGPSCommand_Mode >(mode_);
}
inline void MultiWaypointGPSCommand::set_mode(::MultiWaypointGPSCommand_Mode value) {
  assert(::MultiWaypointGPSCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.mode)
}

// repeated int32 wpt_num = 5 [(.dccl.field) = {
inline int MultiWaypointGPSCommand::wpt_num_size() const {
  return wpt_num_.size();
}
inline void MultiWaypointGPSCommand::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 MultiWaypointGPSCommand::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.wpt_num)
  return wpt_num_.Get(index);
}
inline void MultiWaypointGPSCommand::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.wpt_num)
}
inline void MultiWaypointGPSCommand::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSCommand.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiWaypointGPSCommand::wpt_num() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSCommand.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiWaypointGPSCommand::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSCommand.wpt_num)
  return &wpt_num_;
}

// repeated double latitude = 6 [(.dccl.field) = {
inline int MultiWaypointGPSCommand::latitude_size() const {
  return latitude_.size();
}
inline void MultiWaypointGPSCommand::clear_latitude() {
  latitude_.Clear();
}
inline double MultiWaypointGPSCommand::latitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.latitude)
  return latitude_.Get(index);
}
inline void MultiWaypointGPSCommand::set_latitude(int index, double value) {
  latitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.latitude)
}
inline void MultiWaypointGPSCommand::add_latitude(double value) {
  latitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSCommand.latitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointGPSCommand::latitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSCommand.latitude)
  return latitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointGPSCommand::mutable_latitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSCommand.latitude)
  return &latitude_;
}

// repeated double longitude = 7 [(.dccl.field) = {
inline int MultiWaypointGPSCommand::longitude_size() const {
  return longitude_.size();
}
inline void MultiWaypointGPSCommand::clear_longitude() {
  longitude_.Clear();
}
inline double MultiWaypointGPSCommand::longitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.longitude)
  return longitude_.Get(index);
}
inline void MultiWaypointGPSCommand::set_longitude(int index, double value) {
  longitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.longitude)
}
inline void MultiWaypointGPSCommand::add_longitude(double value) {
  longitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSCommand.longitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointGPSCommand::longitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSCommand.longitude)
  return longitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointGPSCommand::mutable_longitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSCommand.longitude)
  return &longitude_;
}

// repeated float z = 8 [(.dccl.field) = {
inline int MultiWaypointGPSCommand::z_size() const {
  return z_.size();
}
inline void MultiWaypointGPSCommand::clear_z() {
  z_.Clear();
}
inline float MultiWaypointGPSCommand::z(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.z)
  return z_.Get(index);
}
inline void MultiWaypointGPSCommand::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.z)
}
inline void MultiWaypointGPSCommand::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSCommand.z)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointGPSCommand::z() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSCommand.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointGPSCommand::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSCommand.z)
  return &z_;
}

// optional bool end = 9 [(.dccl.field) = {
inline bool MultiWaypointGPSCommand::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointGPSCommand::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointGPSCommand::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointGPSCommand::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointGPSCommand::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSCommand.end)
  return end_;
}
inline void MultiWaypointGPSCommand::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSCommand.end)
}

// -------------------------------------------------------------------

// MultiWaypointGPSResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointGPSResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointGPSResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointGPSResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointGPSResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointGPSResponse::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.source)
  return source_;
}
inline void MultiWaypointGPSResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointGPSResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointGPSResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointGPSResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointGPSResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointGPSResponse::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.destination)
  return destination_;
}
inline void MultiWaypointGPSResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool MultiWaypointGPSResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointGPSResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointGPSResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointGPSResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointGPSResponse::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.time)
  return time_;
}
inline void MultiWaypointGPSResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.time)
}

// required int32 wpt_num = 4 [(.dccl.field) = {
inline bool MultiWaypointGPSResponse::has_wpt_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointGPSResponse::set_has_wpt_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointGPSResponse::clear_has_wpt_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointGPSResponse::clear_wpt_num() {
  wpt_num_ = 0;
  clear_has_wpt_num();
}
inline ::google::protobuf::int32 MultiWaypointGPSResponse::wpt_num() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.wpt_num)
  return wpt_num_;
}
inline void MultiWaypointGPSResponse::set_wpt_num(::google::protobuf::int32 value) {
  set_has_wpt_num();
  wpt_num_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.wpt_num)
}

// repeated double latitude = 5 [(.dccl.field) = {
inline int MultiWaypointGPSResponse::latitude_size() const {
  return latitude_.size();
}
inline void MultiWaypointGPSResponse::clear_latitude() {
  latitude_.Clear();
}
inline double MultiWaypointGPSResponse::latitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.latitude)
  return latitude_.Get(index);
}
inline void MultiWaypointGPSResponse::set_latitude(int index, double value) {
  latitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.latitude)
}
inline void MultiWaypointGPSResponse::add_latitude(double value) {
  latitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSResponse.latitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointGPSResponse::latitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSResponse.latitude)
  return latitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointGPSResponse::mutable_latitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSResponse.latitude)
  return &latitude_;
}

// repeated double longitude = 6 [(.dccl.field) = {
inline int MultiWaypointGPSResponse::longitude_size() const {
  return longitude_.size();
}
inline void MultiWaypointGPSResponse::clear_longitude() {
  longitude_.Clear();
}
inline double MultiWaypointGPSResponse::longitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.longitude)
  return longitude_.Get(index);
}
inline void MultiWaypointGPSResponse::set_longitude(int index, double value) {
  longitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.longitude)
}
inline void MultiWaypointGPSResponse::add_longitude(double value) {
  longitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSResponse.longitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointGPSResponse::longitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSResponse.longitude)
  return longitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointGPSResponse::mutable_longitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSResponse.longitude)
  return &longitude_;
}

// repeated float z = 7 [(.dccl.field) = {
inline int MultiWaypointGPSResponse::z_size() const {
  return z_.size();
}
inline void MultiWaypointGPSResponse::clear_z() {
  z_.Clear();
}
inline float MultiWaypointGPSResponse::z(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.z)
  return z_.Get(index);
}
inline void MultiWaypointGPSResponse::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.z)
}
inline void MultiWaypointGPSResponse::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointGPSResponse.z)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointGPSResponse::z() const {
  // @@protoc_insertion_point(field_list:MultiWaypointGPSResponse.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointGPSResponse::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointGPSResponse.z)
  return &z_;
}

// optional bool end = 8;
inline bool MultiWaypointGPSResponse::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointGPSResponse::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointGPSResponse::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointGPSResponse::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointGPSResponse::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointGPSResponse.end)
  return end_;
}
inline void MultiWaypointGPSResponse::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointGPSResponse.end)
}

// -------------------------------------------------------------------

// MultiWaypointXYZCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointXYZCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointXYZCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointXYZCommand::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.source)
  return source_;
}
inline void MultiWaypointXYZCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointXYZCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointXYZCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointXYZCommand::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.destination)
  return destination_;
}
inline void MultiWaypointXYZCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointXYZCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointXYZCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointXYZCommand::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.time)
  return time_;
}
inline void MultiWaypointXYZCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.time)
}

// required .MultiWaypointXYZCommand.Mode mode = 4;
inline bool MultiWaypointXYZCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointXYZCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointXYZCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::MultiWaypointXYZCommand_Mode MultiWaypointXYZCommand::mode() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.mode)
  return static_cast< ::MultiWaypointXYZCommand_Mode >(mode_);
}
inline void MultiWaypointXYZCommand::set_mode(::MultiWaypointXYZCommand_Mode value) {
  assert(::MultiWaypointXYZCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.mode)
}

// repeated int32 wpt_num = 5 [(.dccl.field) = {
inline int MultiWaypointXYZCommand::wpt_num_size() const {
  return wpt_num_.size();
}
inline void MultiWaypointXYZCommand::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 MultiWaypointXYZCommand::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.wpt_num)
  return wpt_num_.Get(index);
}
inline void MultiWaypointXYZCommand::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.wpt_num)
}
inline void MultiWaypointXYZCommand::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointXYZCommand.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiWaypointXYZCommand::wpt_num() const {
  // @@protoc_insertion_point(field_list:MultiWaypointXYZCommand.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiWaypointXYZCommand::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointXYZCommand.wpt_num)
  return &wpt_num_;
}

// repeated float x = 6 [(.dccl.field) = {
inline int MultiWaypointXYZCommand::x_size() const {
  return x_.size();
}
inline void MultiWaypointXYZCommand::clear_x() {
  x_.Clear();
}
inline float MultiWaypointXYZCommand::x(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.x)
  return x_.Get(index);
}
inline void MultiWaypointXYZCommand::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.x)
}
inline void MultiWaypointXYZCommand::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointXYZCommand.x)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointXYZCommand::x() const {
  // @@protoc_insertion_point(field_list:MultiWaypointXYZCommand.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointXYZCommand::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointXYZCommand.x)
  return &x_;
}

// required float y = 7 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointXYZCommand::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointXYZCommand::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float MultiWaypointXYZCommand::y() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.y)
  return y_;
}
inline void MultiWaypointXYZCommand::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.y)
}

// required float z = 8 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiWaypointXYZCommand::clear_has_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiWaypointXYZCommand::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MultiWaypointXYZCommand::z() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.z)
  return z_;
}
inline void MultiWaypointXYZCommand::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.z)
}

// required bool end = 9 [(.dccl.field) = {
inline bool MultiWaypointXYZCommand::has_end() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiWaypointXYZCommand::set_has_end() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiWaypointXYZCommand::clear_has_end() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiWaypointXYZCommand::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointXYZCommand::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZCommand.end)
  return end_;
}
inline void MultiWaypointXYZCommand::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZCommand.end)
}

// -------------------------------------------------------------------

// MultiWaypointXYZResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointXYZResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointXYZResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointXYZResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointXYZResponse::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.source)
  return source_;
}
inline void MultiWaypointXYZResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointXYZResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointXYZResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointXYZResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointXYZResponse::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.destination)
  return destination_;
}
inline void MultiWaypointXYZResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool MultiWaypointXYZResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointXYZResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointXYZResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointXYZResponse::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.time)
  return time_;
}
inline void MultiWaypointXYZResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.time)
}

// repeated int32 wpt_num = 4 [(.dccl.field) = {
inline int MultiWaypointXYZResponse::wpt_num_size() const {
  return wpt_num_.size();
}
inline void MultiWaypointXYZResponse::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 MultiWaypointXYZResponse::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.wpt_num)
  return wpt_num_.Get(index);
}
inline void MultiWaypointXYZResponse::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.wpt_num)
}
inline void MultiWaypointXYZResponse::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointXYZResponse.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiWaypointXYZResponse::wpt_num() const {
  // @@protoc_insertion_point(field_list:MultiWaypointXYZResponse.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiWaypointXYZResponse::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointXYZResponse.wpt_num)
  return &wpt_num_;
}

// repeated float x = 5 [(.dccl.field) = {
inline int MultiWaypointXYZResponse::x_size() const {
  return x_.size();
}
inline void MultiWaypointXYZResponse::clear_x() {
  x_.Clear();
}
inline float MultiWaypointXYZResponse::x(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.x)
  return x_.Get(index);
}
inline void MultiWaypointXYZResponse::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.x)
}
inline void MultiWaypointXYZResponse::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointXYZResponse.x)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointXYZResponse::x() const {
  // @@protoc_insertion_point(field_list:MultiWaypointXYZResponse.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointXYZResponse::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointXYZResponse.x)
  return &x_;
}

// required float y = 6 [(.dccl.field) = {
inline bool MultiWaypointXYZResponse::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointXYZResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointXYZResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float MultiWaypointXYZResponse::y() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.y)
  return y_;
}
inline void MultiWaypointXYZResponse::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.y)
}

// required float z = 7 [(.dccl.field) = {
inline bool MultiWaypointXYZResponse::has_z() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_z() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointXYZResponse::clear_has_z() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointXYZResponse::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MultiWaypointXYZResponse::z() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.z)
  return z_;
}
inline void MultiWaypointXYZResponse::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.z)
}

// required bool end = 9;
inline bool MultiWaypointXYZResponse::has_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiWaypointXYZResponse::set_has_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiWaypointXYZResponse::clear_has_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiWaypointXYZResponse::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointXYZResponse::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointXYZResponse.end)
  return end_;
}
inline void MultiWaypointXYZResponse::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointXYZResponse.end)
}

// -------------------------------------------------------------------

// ExecuteWaypoints

// required int32 source = 1 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteWaypoints::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteWaypoints::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteWaypoints::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ExecuteWaypoints::source() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.source)
  return source_;
}
inline void ExecuteWaypoints::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteWaypoints::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteWaypoints::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteWaypoints::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ExecuteWaypoints::destination() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.destination)
  return destination_;
}
inline void ExecuteWaypoints::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecuteWaypoints::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecuteWaypoints::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecuteWaypoints::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ExecuteWaypoints::time() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.time)
  return time_;
}
inline void ExecuteWaypoints::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.time)
}

// required bool execute = 4;
inline bool ExecuteWaypoints::has_execute() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecuteWaypoints::set_has_execute() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecuteWaypoints::clear_has_execute() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecuteWaypoints::clear_execute() {
  execute_ = false;
  clear_has_execute();
}
inline bool ExecuteWaypoints::execute() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.execute)
  return execute_;
}
inline void ExecuteWaypoints::set_execute(bool value) {
  set_has_execute();
  execute_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.execute)
}

// required .ExecuteWaypoints.WaypointMode mode = 5;
inline bool ExecuteWaypoints::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecuteWaypoints::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecuteWaypoints::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecuteWaypoints::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ExecuteWaypoints_WaypointMode ExecuteWaypoints::mode() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.mode)
  return static_cast< ::ExecuteWaypoints_WaypointMode >(mode_);
}
inline void ExecuteWaypoints::set_mode(::ExecuteWaypoints_WaypointMode value) {
  assert(::ExecuteWaypoints_WaypointMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RelativePoseCommand_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelativePoseCommand_Frame>() {
  return ::RelativePoseCommand_Frame_descriptor();
}
template <> struct is_proto_enum< ::RelativePoseResponse_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelativePoseResponse_Frame>() {
  return ::RelativePoseResponse_Frame_descriptor();
}
template <> struct is_proto_enum< ::ControllerStateCommand_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ControllerStateCommand_State>() {
  return ::ControllerStateCommand_State_descriptor();
}
template <> struct is_proto_enum< ::ControllerStateResponse_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ControllerStateResponse_State>() {
  return ::ControllerStateResponse_State_descriptor();
}
template <> struct is_proto_enum< ::DirectControlCommand_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DirectControlCommand_Frame>() {
  return ::DirectControlCommand_Frame_descriptor();
}
template <> struct is_proto_enum< ::StateCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StateCommand_Mode>() {
  return ::StateCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::StateCommand_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StateCommand_State>() {
  return ::StateCommand_State_descriptor();
}
template <> struct is_proto_enum< ::StateResponse_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StateResponse_State>() {
  return ::StateResponse_State_descriptor();
}
template <> struct is_proto_enum< ::SingleWaypointCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleWaypointCommand_Mode>() {
  return ::SingleWaypointCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::MultiWaypointGPSCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MultiWaypointGPSCommand_Mode>() {
  return ::MultiWaypointGPSCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::MultiWaypointGPSResponse_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MultiWaypointGPSResponse_Mode>() {
  return ::MultiWaypointGPSResponse_Mode_descriptor();
}
template <> struct is_proto_enum< ::MultiWaypointXYZCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MultiWaypointXYZCommand_Mode>() {
  return ::MultiWaypointXYZCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::ExecuteWaypoints_WaypointMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExecuteWaypoints_WaypointMode>() {
  return ::ExecuteWaypoints_WaypointMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goby_5fmsgs_2eproto
