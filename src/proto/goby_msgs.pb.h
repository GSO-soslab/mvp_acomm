// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: alpha_acomms/src/proto/goby_msgs.proto

#ifndef PROTOBUF_INCLUDED_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto
#define PROTOBUF_INCLUDED_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dccl/option_extensions.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto 

namespace protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto
class ControllerStateCommand;
class ControllerStateCommandDefaultTypeInternal;
extern ControllerStateCommandDefaultTypeInternal _ControllerStateCommand_default_instance_;
class ControllerStateResponse;
class ControllerStateResponseDefaultTypeInternal;
extern ControllerStateResponseDefaultTypeInternal _ControllerStateResponse_default_instance_;
class DirectControlCommand;
class DirectControlCommandDefaultTypeInternal;
extern DirectControlCommandDefaultTypeInternal _DirectControlCommand_default_instance_;
class ExecuteWaypoints;
class ExecuteWaypointsDefaultTypeInternal;
extern ExecuteWaypointsDefaultTypeInternal _ExecuteWaypoints_default_instance_;
class HelmStateCommand;
class HelmStateCommandDefaultTypeInternal;
extern HelmStateCommandDefaultTypeInternal _HelmStateCommand_default_instance_;
class HelmStateResponse;
class HelmStateResponseDefaultTypeInternal;
extern HelmStateResponseDefaultTypeInternal _HelmStateResponse_default_instance_;
class MultiWaypointCommand;
class MultiWaypointCommandDefaultTypeInternal;
extern MultiWaypointCommandDefaultTypeInternal _MultiWaypointCommand_default_instance_;
class MultiWaypointResponse;
class MultiWaypointResponseDefaultTypeInternal;
extern MultiWaypointResponseDefaultTypeInternal _MultiWaypointResponse_default_instance_;
class PoseCommand;
class PoseCommandDefaultTypeInternal;
extern PoseCommandDefaultTypeInternal _PoseCommand_default_instance_;
class PoseResponse;
class PoseResponseDefaultTypeInternal;
extern PoseResponseDefaultTypeInternal _PoseResponse_default_instance_;
class PowerCommand;
class PowerCommandDefaultTypeInternal;
extern PowerCommandDefaultTypeInternal _PowerCommand_default_instance_;
class PowerResponse;
class PowerResponseDefaultTypeInternal;
extern PowerResponseDefaultTypeInternal _PowerResponse_default_instance_;
class RelativePoseCommand;
class RelativePoseCommandDefaultTypeInternal;
extern RelativePoseCommandDefaultTypeInternal _RelativePoseCommand_default_instance_;
class RelativePoseResponse;
class RelativePoseResponseDefaultTypeInternal;
extern RelativePoseResponseDefaultTypeInternal _RelativePoseResponse_default_instance_;
class WaypointCommand;
class WaypointCommandDefaultTypeInternal;
extern WaypointCommandDefaultTypeInternal _WaypointCommand_default_instance_;
namespace google {
namespace protobuf {
template<> ::ControllerStateCommand* Arena::CreateMaybeMessage<::ControllerStateCommand>(Arena*);
template<> ::ControllerStateResponse* Arena::CreateMaybeMessage<::ControllerStateResponse>(Arena*);
template<> ::DirectControlCommand* Arena::CreateMaybeMessage<::DirectControlCommand>(Arena*);
template<> ::ExecuteWaypoints* Arena::CreateMaybeMessage<::ExecuteWaypoints>(Arena*);
template<> ::HelmStateCommand* Arena::CreateMaybeMessage<::HelmStateCommand>(Arena*);
template<> ::HelmStateResponse* Arena::CreateMaybeMessage<::HelmStateResponse>(Arena*);
template<> ::MultiWaypointCommand* Arena::CreateMaybeMessage<::MultiWaypointCommand>(Arena*);
template<> ::MultiWaypointResponse* Arena::CreateMaybeMessage<::MultiWaypointResponse>(Arena*);
template<> ::PoseCommand* Arena::CreateMaybeMessage<::PoseCommand>(Arena*);
template<> ::PoseResponse* Arena::CreateMaybeMessage<::PoseResponse>(Arena*);
template<> ::PowerCommand* Arena::CreateMaybeMessage<::PowerCommand>(Arena*);
template<> ::PowerResponse* Arena::CreateMaybeMessage<::PowerResponse>(Arena*);
template<> ::RelativePoseCommand* Arena::CreateMaybeMessage<::RelativePoseCommand>(Arena*);
template<> ::RelativePoseResponse* Arena::CreateMaybeMessage<::RelativePoseResponse>(Arena*);
template<> ::WaypointCommand* Arena::CreateMaybeMessage<::WaypointCommand>(Arena*);
}  // namespace protobuf
}  // namespace google

enum RelativePoseCommand_Frame {
  RelativePoseCommand_Frame_BASE_LINK = 0,
  RelativePoseCommand_Frame_ODOM = 1,
  RelativePoseCommand_Frame_WORLD = 2,
  RelativePoseCommand_Frame_USBL = 3
};
bool RelativePoseCommand_Frame_IsValid(int value);
const RelativePoseCommand_Frame RelativePoseCommand_Frame_Frame_MIN = RelativePoseCommand_Frame_BASE_LINK;
const RelativePoseCommand_Frame RelativePoseCommand_Frame_Frame_MAX = RelativePoseCommand_Frame_USBL;
const int RelativePoseCommand_Frame_Frame_ARRAYSIZE = RelativePoseCommand_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativePoseCommand_Frame_descriptor();
inline const ::std::string& RelativePoseCommand_Frame_Name(RelativePoseCommand_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativePoseCommand_Frame_descriptor(), value);
}
inline bool RelativePoseCommand_Frame_Parse(
    const ::std::string& name, RelativePoseCommand_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativePoseCommand_Frame>(
    RelativePoseCommand_Frame_descriptor(), name, value);
}
enum RelativePoseResponse_Frame {
  RelativePoseResponse_Frame_BASE_LINK = 0,
  RelativePoseResponse_Frame_ODOM = 1,
  RelativePoseResponse_Frame_WORLD = 2,
  RelativePoseResponse_Frame_USBL = 3
};
bool RelativePoseResponse_Frame_IsValid(int value);
const RelativePoseResponse_Frame RelativePoseResponse_Frame_Frame_MIN = RelativePoseResponse_Frame_BASE_LINK;
const RelativePoseResponse_Frame RelativePoseResponse_Frame_Frame_MAX = RelativePoseResponse_Frame_USBL;
const int RelativePoseResponse_Frame_Frame_ARRAYSIZE = RelativePoseResponse_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativePoseResponse_Frame_descriptor();
inline const ::std::string& RelativePoseResponse_Frame_Name(RelativePoseResponse_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativePoseResponse_Frame_descriptor(), value);
}
inline bool RelativePoseResponse_Frame_Parse(
    const ::std::string& name, RelativePoseResponse_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativePoseResponse_Frame>(
    RelativePoseResponse_Frame_descriptor(), name, value);
}
enum ControllerStateCommand_Mode {
  ControllerStateCommand_Mode_QUERY = 0,
  ControllerStateCommand_Mode_COMMAND = 1
};
bool ControllerStateCommand_Mode_IsValid(int value);
const ControllerStateCommand_Mode ControllerStateCommand_Mode_Mode_MIN = ControllerStateCommand_Mode_QUERY;
const ControllerStateCommand_Mode ControllerStateCommand_Mode_Mode_MAX = ControllerStateCommand_Mode_COMMAND;
const int ControllerStateCommand_Mode_Mode_ARRAYSIZE = ControllerStateCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerStateCommand_Mode_descriptor();
inline const ::std::string& ControllerStateCommand_Mode_Name(ControllerStateCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerStateCommand_Mode_descriptor(), value);
}
inline bool ControllerStateCommand_Mode_Parse(
    const ::std::string& name, ControllerStateCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerStateCommand_Mode>(
    ControllerStateCommand_Mode_descriptor(), name, value);
}
enum ControllerStateCommand_ControllerState {
  ControllerStateCommand_ControllerState_DISABLE = 0,
  ControllerStateCommand_ControllerState_ENABLE = 1
};
bool ControllerStateCommand_ControllerState_IsValid(int value);
const ControllerStateCommand_ControllerState ControllerStateCommand_ControllerState_ControllerState_MIN = ControllerStateCommand_ControllerState_DISABLE;
const ControllerStateCommand_ControllerState ControllerStateCommand_ControllerState_ControllerState_MAX = ControllerStateCommand_ControllerState_ENABLE;
const int ControllerStateCommand_ControllerState_ControllerState_ARRAYSIZE = ControllerStateCommand_ControllerState_ControllerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerStateCommand_ControllerState_descriptor();
inline const ::std::string& ControllerStateCommand_ControllerState_Name(ControllerStateCommand_ControllerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerStateCommand_ControllerState_descriptor(), value);
}
inline bool ControllerStateCommand_ControllerState_Parse(
    const ::std::string& name, ControllerStateCommand_ControllerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerStateCommand_ControllerState>(
    ControllerStateCommand_ControllerState_descriptor(), name, value);
}
enum ControllerStateResponse_ControllerState {
  ControllerStateResponse_ControllerState_DISABLE = 0,
  ControllerStateResponse_ControllerState_ENABLE = 1
};
bool ControllerStateResponse_ControllerState_IsValid(int value);
const ControllerStateResponse_ControllerState ControllerStateResponse_ControllerState_ControllerState_MIN = ControllerStateResponse_ControllerState_DISABLE;
const ControllerStateResponse_ControllerState ControllerStateResponse_ControllerState_ControllerState_MAX = ControllerStateResponse_ControllerState_ENABLE;
const int ControllerStateResponse_ControllerState_ControllerState_ARRAYSIZE = ControllerStateResponse_ControllerState_ControllerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerStateResponse_ControllerState_descriptor();
inline const ::std::string& ControllerStateResponse_ControllerState_Name(ControllerStateResponse_ControllerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerStateResponse_ControllerState_descriptor(), value);
}
inline bool ControllerStateResponse_ControllerState_Parse(
    const ::std::string& name, ControllerStateResponse_ControllerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerStateResponse_ControllerState>(
    ControllerStateResponse_ControllerState_descriptor(), name, value);
}
enum DirectControlCommand_Frame {
  DirectControlCommand_Frame_BASE_LINK = 0,
  DirectControlCommand_Frame_ODOM = 1,
  DirectControlCommand_Frame_WORLD = 2,
  DirectControlCommand_Frame_USBL = 3
};
bool DirectControlCommand_Frame_IsValid(int value);
const DirectControlCommand_Frame DirectControlCommand_Frame_Frame_MIN = DirectControlCommand_Frame_BASE_LINK;
const DirectControlCommand_Frame DirectControlCommand_Frame_Frame_MAX = DirectControlCommand_Frame_USBL;
const int DirectControlCommand_Frame_Frame_ARRAYSIZE = DirectControlCommand_Frame_Frame_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectControlCommand_Frame_descriptor();
inline const ::std::string& DirectControlCommand_Frame_Name(DirectControlCommand_Frame value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectControlCommand_Frame_descriptor(), value);
}
inline bool DirectControlCommand_Frame_Parse(
    const ::std::string& name, DirectControlCommand_Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectControlCommand_Frame>(
    DirectControlCommand_Frame_descriptor(), name, value);
}
enum HelmStateCommand_Mode {
  HelmStateCommand_Mode_QUERY = 0,
  HelmStateCommand_Mode_COMMAND = 1
};
bool HelmStateCommand_Mode_IsValid(int value);
const HelmStateCommand_Mode HelmStateCommand_Mode_Mode_MIN = HelmStateCommand_Mode_QUERY;
const HelmStateCommand_Mode HelmStateCommand_Mode_Mode_MAX = HelmStateCommand_Mode_COMMAND;
const int HelmStateCommand_Mode_Mode_ARRAYSIZE = HelmStateCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* HelmStateCommand_Mode_descriptor();
inline const ::std::string& HelmStateCommand_Mode_Name(HelmStateCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    HelmStateCommand_Mode_descriptor(), value);
}
inline bool HelmStateCommand_Mode_Parse(
    const ::std::string& name, HelmStateCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HelmStateCommand_Mode>(
    HelmStateCommand_Mode_descriptor(), name, value);
}
enum HelmStateCommand_HelmState {
  HelmStateCommand_HelmState_KILL = 0,
  HelmStateCommand_HelmState_START = 1,
  HelmStateCommand_HelmState_SURVEY_LOCAL = 2,
  HelmStateCommand_HelmState_SURVEY_GLOBAL = 3,
  HelmStateCommand_HelmState_DIRECT_CONTROL = 4,
  HelmStateCommand_HelmState_SURVEY_3D = 5
};
bool HelmStateCommand_HelmState_IsValid(int value);
const HelmStateCommand_HelmState HelmStateCommand_HelmState_HelmState_MIN = HelmStateCommand_HelmState_KILL;
const HelmStateCommand_HelmState HelmStateCommand_HelmState_HelmState_MAX = HelmStateCommand_HelmState_SURVEY_3D;
const int HelmStateCommand_HelmState_HelmState_ARRAYSIZE = HelmStateCommand_HelmState_HelmState_MAX + 1;

const ::google::protobuf::EnumDescriptor* HelmStateCommand_HelmState_descriptor();
inline const ::std::string& HelmStateCommand_HelmState_Name(HelmStateCommand_HelmState value) {
  return ::google::protobuf::internal::NameOfEnum(
    HelmStateCommand_HelmState_descriptor(), value);
}
inline bool HelmStateCommand_HelmState_Parse(
    const ::std::string& name, HelmStateCommand_HelmState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HelmStateCommand_HelmState>(
    HelmStateCommand_HelmState_descriptor(), name, value);
}
enum HelmStateResponse_HelmState {
  HelmStateResponse_HelmState_KILL = 0,
  HelmStateResponse_HelmState_START = 1,
  HelmStateResponse_HelmState_SURVEY_LOCAL = 2,
  HelmStateResponse_HelmState_SURVEY_GLOBAL = 3,
  HelmStateResponse_HelmState_DIRECT_CONTROL = 4,
  HelmStateResponse_HelmState_SURVEY_3D = 5
};
bool HelmStateResponse_HelmState_IsValid(int value);
const HelmStateResponse_HelmState HelmStateResponse_HelmState_HelmState_MIN = HelmStateResponse_HelmState_KILL;
const HelmStateResponse_HelmState HelmStateResponse_HelmState_HelmState_MAX = HelmStateResponse_HelmState_SURVEY_3D;
const int HelmStateResponse_HelmState_HelmState_ARRAYSIZE = HelmStateResponse_HelmState_HelmState_MAX + 1;

const ::google::protobuf::EnumDescriptor* HelmStateResponse_HelmState_descriptor();
inline const ::std::string& HelmStateResponse_HelmState_Name(HelmStateResponse_HelmState value) {
  return ::google::protobuf::internal::NameOfEnum(
    HelmStateResponse_HelmState_descriptor(), value);
}
inline bool HelmStateResponse_HelmState_Parse(
    const ::std::string& name, HelmStateResponse_HelmState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HelmStateResponse_HelmState>(
    HelmStateResponse_HelmState_descriptor(), name, value);
}
enum WaypointCommand_Mode {
  WaypointCommand_Mode_QUERY = 0,
  WaypointCommand_Mode_COMMAND = 1
};
bool WaypointCommand_Mode_IsValid(int value);
const WaypointCommand_Mode WaypointCommand_Mode_Mode_MIN = WaypointCommand_Mode_QUERY;
const WaypointCommand_Mode WaypointCommand_Mode_Mode_MAX = WaypointCommand_Mode_COMMAND;
const int WaypointCommand_Mode_Mode_ARRAYSIZE = WaypointCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* WaypointCommand_Mode_descriptor();
inline const ::std::string& WaypointCommand_Mode_Name(WaypointCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    WaypointCommand_Mode_descriptor(), value);
}
inline bool WaypointCommand_Mode_Parse(
    const ::std::string& name, WaypointCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WaypointCommand_Mode>(
    WaypointCommand_Mode_descriptor(), name, value);
}
enum MultiWaypointCommand_Mode {
  MultiWaypointCommand_Mode_QUERY = 0,
  MultiWaypointCommand_Mode_COMMAND = 1
};
bool MultiWaypointCommand_Mode_IsValid(int value);
const MultiWaypointCommand_Mode MultiWaypointCommand_Mode_Mode_MIN = MultiWaypointCommand_Mode_QUERY;
const MultiWaypointCommand_Mode MultiWaypointCommand_Mode_Mode_MAX = MultiWaypointCommand_Mode_COMMAND;
const int MultiWaypointCommand_Mode_Mode_ARRAYSIZE = MultiWaypointCommand_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiWaypointCommand_Mode_descriptor();
inline const ::std::string& MultiWaypointCommand_Mode_Name(MultiWaypointCommand_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiWaypointCommand_Mode_descriptor(), value);
}
inline bool MultiWaypointCommand_Mode_Parse(
    const ::std::string& name, MultiWaypointCommand_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiWaypointCommand_Mode>(
    MultiWaypointCommand_Mode_descriptor(), name, value);
}
enum ExecuteWaypoints_ExecuteMode {
  ExecuteWaypoints_ExecuteMode_APPEND = 0,
  ExecuteWaypoints_ExecuteMode_UPDATE = 1
};
bool ExecuteWaypoints_ExecuteMode_IsValid(int value);
const ExecuteWaypoints_ExecuteMode ExecuteWaypoints_ExecuteMode_ExecuteMode_MIN = ExecuteWaypoints_ExecuteMode_APPEND;
const ExecuteWaypoints_ExecuteMode ExecuteWaypoints_ExecuteMode_ExecuteMode_MAX = ExecuteWaypoints_ExecuteMode_UPDATE;
const int ExecuteWaypoints_ExecuteMode_ExecuteMode_ARRAYSIZE = ExecuteWaypoints_ExecuteMode_ExecuteMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteWaypoints_ExecuteMode_descriptor();
inline const ::std::string& ExecuteWaypoints_ExecuteMode_Name(ExecuteWaypoints_ExecuteMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteWaypoints_ExecuteMode_descriptor(), value);
}
inline bool ExecuteWaypoints_ExecuteMode_Parse(
    const ::std::string& name, ExecuteWaypoints_ExecuteMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteWaypoints_ExecuteMode>(
    ExecuteWaypoints_ExecuteMode_descriptor(), name, value);
}
// ===================================================================

class PoseCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PoseCommand) */ {
 public:
  PoseCommand();
  virtual ~PoseCommand();

  PoseCommand(const PoseCommand& from);

  inline PoseCommand& operator=(const PoseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseCommand(PoseCommand&& from) noexcept
    : PoseCommand() {
    *this = ::std::move(from);
  }

  inline PoseCommand& operator=(PoseCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseCommand* internal_default_instance() {
    return reinterpret_cast<const PoseCommand*>(
               &_PoseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PoseCommand* other);
  friend void swap(PoseCommand& a, PoseCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseCommand* New() const final {
    return CreateMaybeMessage<PoseCommand>(NULL);
  }

  PoseCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoseCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoseCommand& from);
  void MergeFrom(const PoseCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:PoseCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PoseResponse) */ {
 public:
  PoseResponse();
  virtual ~PoseResponse();

  PoseResponse(const PoseResponse& from);

  inline PoseResponse& operator=(const PoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseResponse(PoseResponse&& from) noexcept
    : PoseResponse() {
    *this = ::std::move(from);
  }

  inline PoseResponse& operator=(PoseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseResponse* internal_default_instance() {
    return reinterpret_cast<const PoseResponse*>(
               &_PoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PoseResponse* other);
  friend void swap(PoseResponse& a, PoseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseResponse* New() const final {
    return CreateMaybeMessage<PoseResponse>(NULL);
  }

  PoseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoseResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoseResponse& from);
  void MergeFrom(const PoseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required double latitude = 4 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 5 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // required float altitude = 6 [(.dccl.field) = {
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 6;
  float altitude() const;
  void set_altitude(float value);

  // required float quat_x = 7 [(.dccl.field) = {
  bool has_quat_x() const;
  void clear_quat_x();
  static const int kQuatXFieldNumber = 7;
  float quat_x() const;
  void set_quat_x(float value);

  // required float quat_y = 8 [(.dccl.field) = {
  bool has_quat_y() const;
  void clear_quat_y();
  static const int kQuatYFieldNumber = 8;
  float quat_y() const;
  void set_quat_y(float value);

  // required float quat_z = 9 [(.dccl.field) = {
  bool has_quat_z() const;
  void clear_quat_z();
  static const int kQuatZFieldNumber = 9;
  float quat_z() const;
  void set_quat_z(float value);

  // required float quat_w = 10 [(.dccl.field) = {
  bool has_quat_w() const;
  void clear_quat_w();
  static const int kQuatWFieldNumber = 10;
  float quat_w() const;
  void set_quat_w(float value);

  // @@protoc_insertion_point(class_scope:PoseResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_altitude();
  void clear_has_altitude();
  void set_has_quat_x();
  void clear_has_quat_x();
  void set_has_quat_y();
  void clear_has_quat_y();
  void set_has_quat_z();
  void clear_has_quat_z();
  void set_has_quat_w();
  void clear_has_quat_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  double latitude_;
  double longitude_;
  float altitude_;
  float quat_x_;
  float quat_y_;
  float quat_z_;
  float quat_w_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PowerCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PowerCommand) */ {
 public:
  PowerCommand();
  virtual ~PowerCommand();

  PowerCommand(const PowerCommand& from);

  inline PowerCommand& operator=(const PowerCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerCommand(PowerCommand&& from) noexcept
    : PowerCommand() {
    *this = ::std::move(from);
  }

  inline PowerCommand& operator=(PowerCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerCommand* internal_default_instance() {
    return reinterpret_cast<const PowerCommand*>(
               &_PowerCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PowerCommand* other);
  friend void swap(PowerCommand& a, PowerCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerCommand* New() const final {
    return CreateMaybeMessage<PowerCommand>(NULL);
  }

  PowerCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PowerCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PowerCommand& from);
  void MergeFrom(const PowerCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // @@protoc_insertion_point(class_scope:PowerCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PowerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PowerResponse) */ {
 public:
  PowerResponse();
  virtual ~PowerResponse();

  PowerResponse(const PowerResponse& from);

  inline PowerResponse& operator=(const PowerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerResponse(PowerResponse&& from) noexcept
    : PowerResponse() {
    *this = ::std::move(from);
  }

  inline PowerResponse& operator=(PowerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerResponse* internal_default_instance() {
    return reinterpret_cast<const PowerResponse*>(
               &_PowerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PowerResponse* other);
  friend void swap(PowerResponse& a, PowerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerResponse* New() const final {
    return CreateMaybeMessage<PowerResponse>(NULL);
  }

  PowerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PowerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PowerResponse& from);
  void MergeFrom(const PowerResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required float battery_voltage = 4 [(.dccl.field) = {
  bool has_battery_voltage() const;
  void clear_battery_voltage();
  static const int kBatteryVoltageFieldNumber = 4;
  float battery_voltage() const;
  void set_battery_voltage(float value);

  // required float current = 5 [(.dccl.field) = {
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 5;
  float current() const;
  void set_current(float value);

  // @@protoc_insertion_point(class_scope:PowerResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_battery_voltage();
  void clear_has_battery_voltage();
  void set_has_current();
  void clear_has_current();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  float battery_voltage_;
  float current_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePoseCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RelativePoseCommand) */ {
 public:
  RelativePoseCommand();
  virtual ~RelativePoseCommand();

  RelativePoseCommand(const RelativePoseCommand& from);

  inline RelativePoseCommand& operator=(const RelativePoseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePoseCommand(RelativePoseCommand&& from) noexcept
    : RelativePoseCommand() {
    *this = ::std::move(from);
  }

  inline RelativePoseCommand& operator=(RelativePoseCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePoseCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePoseCommand* internal_default_instance() {
    return reinterpret_cast<const RelativePoseCommand*>(
               &_RelativePoseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RelativePoseCommand* other);
  friend void swap(RelativePoseCommand& a, RelativePoseCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePoseCommand* New() const final {
    return CreateMaybeMessage<RelativePoseCommand>(NULL);
  }

  RelativePoseCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePoseCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePoseCommand& from);
  void MergeFrom(const RelativePoseCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePoseCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelativePoseCommand_Frame Frame;
  static const Frame BASE_LINK =
    RelativePoseCommand_Frame_BASE_LINK;
  static const Frame ODOM =
    RelativePoseCommand_Frame_ODOM;
  static const Frame WORLD =
    RelativePoseCommand_Frame_WORLD;
  static const Frame USBL =
    RelativePoseCommand_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return RelativePoseCommand_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    RelativePoseCommand_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    RelativePoseCommand_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    RelativePoseCommand_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return RelativePoseCommand_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return RelativePoseCommand_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return RelativePoseCommand_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .RelativePoseCommand.Frame parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  ::RelativePoseCommand_Frame parent() const;
  void set_parent(::RelativePoseCommand_Frame value);

  // required .RelativePoseCommand.Frame child = 5;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::RelativePoseCommand_Frame child() const;
  void set_child(::RelativePoseCommand_Frame value);

  // @@protoc_insertion_point(class_scope:RelativePoseCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_parent();
  void clear_has_parent();
  void set_has_child();
  void clear_has_child();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int parent_;
  int child_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePoseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RelativePoseResponse) */ {
 public:
  RelativePoseResponse();
  virtual ~RelativePoseResponse();

  RelativePoseResponse(const RelativePoseResponse& from);

  inline RelativePoseResponse& operator=(const RelativePoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePoseResponse(RelativePoseResponse&& from) noexcept
    : RelativePoseResponse() {
    *this = ::std::move(from);
  }

  inline RelativePoseResponse& operator=(RelativePoseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePoseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePoseResponse* internal_default_instance() {
    return reinterpret_cast<const RelativePoseResponse*>(
               &_RelativePoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RelativePoseResponse* other);
  friend void swap(RelativePoseResponse& a, RelativePoseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePoseResponse* New() const final {
    return CreateMaybeMessage<RelativePoseResponse>(NULL);
  }

  RelativePoseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePoseResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePoseResponse& from);
  void MergeFrom(const RelativePoseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePoseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelativePoseResponse_Frame Frame;
  static const Frame BASE_LINK =
    RelativePoseResponse_Frame_BASE_LINK;
  static const Frame ODOM =
    RelativePoseResponse_Frame_ODOM;
  static const Frame WORLD =
    RelativePoseResponse_Frame_WORLD;
  static const Frame USBL =
    RelativePoseResponse_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return RelativePoseResponse_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    RelativePoseResponse_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    RelativePoseResponse_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    RelativePoseResponse_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return RelativePoseResponse_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return RelativePoseResponse_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return RelativePoseResponse_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .RelativePoseResponse.Frame parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  ::RelativePoseResponse_Frame parent() const;
  void set_parent(::RelativePoseResponse_Frame value);

  // required .RelativePoseResponse.Frame child = 5;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::RelativePoseResponse_Frame child() const;
  void set_child(::RelativePoseResponse_Frame value);

  // required double latitude = 6 [(.dccl.field) = {
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 7 [(.dccl.field) = {
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 7;
  double longitude() const;
  void set_longitude(double value);

  // required float x = 8 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 8;
  float x() const;
  void set_x(float value);

  // required float y = 9 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 9;
  float y() const;
  void set_y(float value);

  // required float z = 10 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 10;
  float z() const;
  void set_z(float value);

  // required float quat_x = 11 [(.dccl.field) = {
  bool has_quat_x() const;
  void clear_quat_x();
  static const int kQuatXFieldNumber = 11;
  float quat_x() const;
  void set_quat_x(float value);

  // required float quat_y = 12 [(.dccl.field) = {
  bool has_quat_y() const;
  void clear_quat_y();
  static const int kQuatYFieldNumber = 12;
  float quat_y() const;
  void set_quat_y(float value);

  // required float quat_z = 13 [(.dccl.field) = {
  bool has_quat_z() const;
  void clear_quat_z();
  static const int kQuatZFieldNumber = 13;
  float quat_z() const;
  void set_quat_z(float value);

  // required float quat_w = 14 [(.dccl.field) = {
  bool has_quat_w() const;
  void clear_quat_w();
  static const int kQuatWFieldNumber = 14;
  float quat_w() const;
  void set_quat_w(float value);

  // @@protoc_insertion_point(class_scope:RelativePoseResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_parent();
  void clear_has_parent();
  void set_has_child();
  void clear_has_child();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_quat_x();
  void clear_has_quat_x();
  void set_has_quat_y();
  void clear_has_quat_y();
  void set_has_quat_z();
  void clear_has_quat_z();
  void set_has_quat_w();
  void clear_has_quat_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int parent_;
  int child_;
  double latitude_;
  double longitude_;
  float x_;
  float y_;
  float z_;
  float quat_x_;
  float quat_y_;
  float quat_z_;
  float quat_w_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerStateCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControllerStateCommand) */ {
 public:
  ControllerStateCommand();
  virtual ~ControllerStateCommand();

  ControllerStateCommand(const ControllerStateCommand& from);

  inline ControllerStateCommand& operator=(const ControllerStateCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerStateCommand(ControllerStateCommand&& from) noexcept
    : ControllerStateCommand() {
    *this = ::std::move(from);
  }

  inline ControllerStateCommand& operator=(ControllerStateCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerStateCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerStateCommand* internal_default_instance() {
    return reinterpret_cast<const ControllerStateCommand*>(
               &_ControllerStateCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ControllerStateCommand* other);
  friend void swap(ControllerStateCommand& a, ControllerStateCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerStateCommand* New() const final {
    return CreateMaybeMessage<ControllerStateCommand>(NULL);
  }

  ControllerStateCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControllerStateCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControllerStateCommand& from);
  void MergeFrom(const ControllerStateCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerStateCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControllerStateCommand_Mode Mode;
  static const Mode QUERY =
    ControllerStateCommand_Mode_QUERY;
  static const Mode COMMAND =
    ControllerStateCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return ControllerStateCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    ControllerStateCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    ControllerStateCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    ControllerStateCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return ControllerStateCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return ControllerStateCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return ControllerStateCommand_Mode_Parse(name, value);
  }

  typedef ControllerStateCommand_ControllerState ControllerState;
  static const ControllerState DISABLE =
    ControllerStateCommand_ControllerState_DISABLE;
  static const ControllerState ENABLE =
    ControllerStateCommand_ControllerState_ENABLE;
  static inline bool ControllerState_IsValid(int value) {
    return ControllerStateCommand_ControllerState_IsValid(value);
  }
  static const ControllerState ControllerState_MIN =
    ControllerStateCommand_ControllerState_ControllerState_MIN;
  static const ControllerState ControllerState_MAX =
    ControllerStateCommand_ControllerState_ControllerState_MAX;
  static const int ControllerState_ARRAYSIZE =
    ControllerStateCommand_ControllerState_ControllerState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControllerState_descriptor() {
    return ControllerStateCommand_ControllerState_descriptor();
  }
  static inline const ::std::string& ControllerState_Name(ControllerState value) {
    return ControllerStateCommand_ControllerState_Name(value);
  }
  static inline bool ControllerState_Parse(const ::std::string& name,
      ControllerState* value) {
    return ControllerStateCommand_ControllerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .ControllerStateCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::ControllerStateCommand_Mode mode() const;
  void set_mode(::ControllerStateCommand_Mode value);

  // optional .ControllerStateCommand.ControllerState state = 5 [(.dccl.field) = {
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::ControllerStateCommand_ControllerState state() const;
  void set_state(::ControllerStateCommand_ControllerState value);

  // @@protoc_insertion_point(class_scope:ControllerStateCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  int state_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControllerStateResponse) */ {
 public:
  ControllerStateResponse();
  virtual ~ControllerStateResponse();

  ControllerStateResponse(const ControllerStateResponse& from);

  inline ControllerStateResponse& operator=(const ControllerStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerStateResponse(ControllerStateResponse&& from) noexcept
    : ControllerStateResponse() {
    *this = ::std::move(from);
  }

  inline ControllerStateResponse& operator=(ControllerStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerStateResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerStateResponse*>(
               &_ControllerStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ControllerStateResponse* other);
  friend void swap(ControllerStateResponse& a, ControllerStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerStateResponse* New() const final {
    return CreateMaybeMessage<ControllerStateResponse>(NULL);
  }

  ControllerStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControllerStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControllerStateResponse& from);
  void MergeFrom(const ControllerStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControllerStateResponse_ControllerState ControllerState;
  static const ControllerState DISABLE =
    ControllerStateResponse_ControllerState_DISABLE;
  static const ControllerState ENABLE =
    ControllerStateResponse_ControllerState_ENABLE;
  static inline bool ControllerState_IsValid(int value) {
    return ControllerStateResponse_ControllerState_IsValid(value);
  }
  static const ControllerState ControllerState_MIN =
    ControllerStateResponse_ControllerState_ControllerState_MIN;
  static const ControllerState ControllerState_MAX =
    ControllerStateResponse_ControllerState_ControllerState_MAX;
  static const int ControllerState_ARRAYSIZE =
    ControllerStateResponse_ControllerState_ControllerState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControllerState_descriptor() {
    return ControllerStateResponse_ControllerState_descriptor();
  }
  static inline const ::std::string& ControllerState_Name(ControllerState value) {
    return ControllerStateResponse_ControllerState_Name(value);
  }
  static inline bool ControllerState_Parse(const ::std::string& name,
      ControllerState* value) {
    return ControllerStateResponse_ControllerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional .ControllerStateResponse.ControllerState state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::ControllerStateResponse_ControllerState state() const;
  void set_state(::ControllerStateResponse_ControllerState value);

  // @@protoc_insertion_point(class_scope:ControllerStateResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int state_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectControlCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DirectControlCommand) */ {
 public:
  DirectControlCommand();
  virtual ~DirectControlCommand();

  DirectControlCommand(const DirectControlCommand& from);

  inline DirectControlCommand& operator=(const DirectControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectControlCommand(DirectControlCommand&& from) noexcept
    : DirectControlCommand() {
    *this = ::std::move(from);
  }

  inline DirectControlCommand& operator=(DirectControlCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectControlCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectControlCommand* internal_default_instance() {
    return reinterpret_cast<const DirectControlCommand*>(
               &_DirectControlCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DirectControlCommand* other);
  friend void swap(DirectControlCommand& a, DirectControlCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectControlCommand* New() const final {
    return CreateMaybeMessage<DirectControlCommand>(NULL);
  }

  DirectControlCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectControlCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectControlCommand& from);
  void MergeFrom(const DirectControlCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectControlCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DirectControlCommand_Frame Frame;
  static const Frame BASE_LINK =
    DirectControlCommand_Frame_BASE_LINK;
  static const Frame ODOM =
    DirectControlCommand_Frame_ODOM;
  static const Frame WORLD =
    DirectControlCommand_Frame_WORLD;
  static const Frame USBL =
    DirectControlCommand_Frame_USBL;
  static inline bool Frame_IsValid(int value) {
    return DirectControlCommand_Frame_IsValid(value);
  }
  static const Frame Frame_MIN =
    DirectControlCommand_Frame_Frame_MIN;
  static const Frame Frame_MAX =
    DirectControlCommand_Frame_Frame_MAX;
  static const int Frame_ARRAYSIZE =
    DirectControlCommand_Frame_Frame_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Frame_descriptor() {
    return DirectControlCommand_Frame_descriptor();
  }
  static inline const ::std::string& Frame_Name(Frame value) {
    return DirectControlCommand_Frame_Name(value);
  }
  static inline bool Frame_Parse(const ::std::string& name,
      Frame* value) {
    return DirectControlCommand_Frame_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .DirectControlCommand.Frame frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::DirectControlCommand_Frame frame() const;
  void set_frame(::DirectControlCommand_Frame value);

  // required float x = 5 [(.dccl.field) = {
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 5;
  float x() const;
  void set_x(float value);

  // required float y = 6 [(.dccl.field) = {
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 6;
  float y() const;
  void set_y(float value);

  // required float z = 7 [(.dccl.field) = {
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z() const;
  void set_z(float value);

  // required float roll = 8 [(.dccl.field) = {
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 8;
  float roll() const;
  void set_roll(float value);

  // required float pitch = 9 [(.dccl.field) = {
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 9;
  float pitch() const;
  void set_pitch(float value);

  // required float yaw = 10 [(.dccl.field) = {
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 10;
  float yaw() const;
  void set_yaw(float value);

  // required float u = 11 [(.dccl.field) = {
  bool has_u() const;
  void clear_u();
  static const int kUFieldNumber = 11;
  float u() const;
  void set_u(float value);

  // required float v = 12 [(.dccl.field) = {
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 12;
  float v() const;
  void set_v(float value);

  // required float w = 13 [(.dccl.field) = {
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 13;
  float w() const;
  void set_w(float value);

  // required float p = 14 [(.dccl.field) = {
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 14;
  float p() const;
  void set_p(float value);

  // required float q = 15 [(.dccl.field) = {
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 15;
  float q() const;
  void set_q(float value);

  // required float r = 16 [(.dccl.field) = {
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 16;
  float r() const;
  void set_r(float value);

  // @@protoc_insertion_point(class_scope:DirectControlCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_frame();
  void clear_has_frame();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_roll();
  void clear_has_roll();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_u();
  void clear_has_u();
  void set_has_v();
  void clear_has_v();
  void set_has_w();
  void clear_has_w();
  void set_has_p();
  void clear_has_p();
  void set_has_q();
  void clear_has_q();
  void set_has_r();
  void clear_has_r();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int frame_;
  float x_;
  float y_;
  float z_;
  float roll_;
  float pitch_;
  float yaw_;
  float u_;
  float v_;
  float w_;
  float p_;
  float q_;
  float r_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelmStateCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HelmStateCommand) */ {
 public:
  HelmStateCommand();
  virtual ~HelmStateCommand();

  HelmStateCommand(const HelmStateCommand& from);

  inline HelmStateCommand& operator=(const HelmStateCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelmStateCommand(HelmStateCommand&& from) noexcept
    : HelmStateCommand() {
    *this = ::std::move(from);
  }

  inline HelmStateCommand& operator=(HelmStateCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelmStateCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelmStateCommand* internal_default_instance() {
    return reinterpret_cast<const HelmStateCommand*>(
               &_HelmStateCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HelmStateCommand* other);
  friend void swap(HelmStateCommand& a, HelmStateCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelmStateCommand* New() const final {
    return CreateMaybeMessage<HelmStateCommand>(NULL);
  }

  HelmStateCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelmStateCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelmStateCommand& from);
  void MergeFrom(const HelmStateCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelmStateCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HelmStateCommand_Mode Mode;
  static const Mode QUERY =
    HelmStateCommand_Mode_QUERY;
  static const Mode COMMAND =
    HelmStateCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return HelmStateCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    HelmStateCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    HelmStateCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    HelmStateCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return HelmStateCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return HelmStateCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return HelmStateCommand_Mode_Parse(name, value);
  }

  typedef HelmStateCommand_HelmState HelmState;
  static const HelmState KILL =
    HelmStateCommand_HelmState_KILL;
  static const HelmState START =
    HelmStateCommand_HelmState_START;
  static const HelmState SURVEY_LOCAL =
    HelmStateCommand_HelmState_SURVEY_LOCAL;
  static const HelmState SURVEY_GLOBAL =
    HelmStateCommand_HelmState_SURVEY_GLOBAL;
  static const HelmState DIRECT_CONTROL =
    HelmStateCommand_HelmState_DIRECT_CONTROL;
  static const HelmState SURVEY_3D =
    HelmStateCommand_HelmState_SURVEY_3D;
  static inline bool HelmState_IsValid(int value) {
    return HelmStateCommand_HelmState_IsValid(value);
  }
  static const HelmState HelmState_MIN =
    HelmStateCommand_HelmState_HelmState_MIN;
  static const HelmState HelmState_MAX =
    HelmStateCommand_HelmState_HelmState_MAX;
  static const int HelmState_ARRAYSIZE =
    HelmStateCommand_HelmState_HelmState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HelmState_descriptor() {
    return HelmStateCommand_HelmState_descriptor();
  }
  static inline const ::std::string& HelmState_Name(HelmState value) {
    return HelmStateCommand_HelmState_Name(value);
  }
  static inline bool HelmState_Parse(const ::std::string& name,
      HelmState* value) {
    return HelmStateCommand_HelmState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .HelmStateCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::HelmStateCommand_Mode mode() const;
  void set_mode(::HelmStateCommand_Mode value);

  // optional .HelmStateCommand.HelmState state = 5 [(.dccl.field) = {
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::HelmStateCommand_HelmState state() const;
  void set_state(::HelmStateCommand_HelmState value);

  // @@protoc_insertion_point(class_scope:HelmStateCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  int state_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelmStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HelmStateResponse) */ {
 public:
  HelmStateResponse();
  virtual ~HelmStateResponse();

  HelmStateResponse(const HelmStateResponse& from);

  inline HelmStateResponse& operator=(const HelmStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelmStateResponse(HelmStateResponse&& from) noexcept
    : HelmStateResponse() {
    *this = ::std::move(from);
  }

  inline HelmStateResponse& operator=(HelmStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelmStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelmStateResponse* internal_default_instance() {
    return reinterpret_cast<const HelmStateResponse*>(
               &_HelmStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(HelmStateResponse* other);
  friend void swap(HelmStateResponse& a, HelmStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelmStateResponse* New() const final {
    return CreateMaybeMessage<HelmStateResponse>(NULL);
  }

  HelmStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelmStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelmStateResponse& from);
  void MergeFrom(const HelmStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelmStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HelmStateResponse_HelmState HelmState;
  static const HelmState KILL =
    HelmStateResponse_HelmState_KILL;
  static const HelmState START =
    HelmStateResponse_HelmState_START;
  static const HelmState SURVEY_LOCAL =
    HelmStateResponse_HelmState_SURVEY_LOCAL;
  static const HelmState SURVEY_GLOBAL =
    HelmStateResponse_HelmState_SURVEY_GLOBAL;
  static const HelmState DIRECT_CONTROL =
    HelmStateResponse_HelmState_DIRECT_CONTROL;
  static const HelmState SURVEY_3D =
    HelmStateResponse_HelmState_SURVEY_3D;
  static inline bool HelmState_IsValid(int value) {
    return HelmStateResponse_HelmState_IsValid(value);
  }
  static const HelmState HelmState_MIN =
    HelmStateResponse_HelmState_HelmState_MIN;
  static const HelmState HelmState_MAX =
    HelmStateResponse_HelmState_HelmState_MAX;
  static const int HelmState_ARRAYSIZE =
    HelmStateResponse_HelmState_HelmState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HelmState_descriptor() {
    return HelmStateResponse_HelmState_descriptor();
  }
  static inline const ::std::string& HelmState_Name(HelmState value) {
    return HelmStateResponse_HelmState_Name(value);
  }
  static inline bool HelmState_Parse(const ::std::string& name,
      HelmState* value) {
    return HelmStateResponse_HelmState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .HelmStateResponse.HelmState helm_state = 4;
  bool has_helm_state() const;
  void clear_helm_state();
  static const int kHelmStateFieldNumber = 4;
  ::HelmStateResponse_HelmState helm_state() const;
  void set_helm_state(::HelmStateResponse_HelmState value);

  // @@protoc_insertion_point(class_scope:HelmStateResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_helm_state();
  void clear_has_helm_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int helm_state_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaypointCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WaypointCommand) */ {
 public:
  WaypointCommand();
  virtual ~WaypointCommand();

  WaypointCommand(const WaypointCommand& from);

  inline WaypointCommand& operator=(const WaypointCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointCommand(WaypointCommand&& from) noexcept
    : WaypointCommand() {
    *this = ::std::move(from);
  }

  inline WaypointCommand& operator=(WaypointCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WaypointCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointCommand* internal_default_instance() {
    return reinterpret_cast<const WaypointCommand*>(
               &_WaypointCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WaypointCommand* other);
  friend void swap(WaypointCommand& a, WaypointCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointCommand* New() const final {
    return CreateMaybeMessage<WaypointCommand>(NULL);
  }

  WaypointCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaypointCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaypointCommand& from);
  void MergeFrom(const WaypointCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaypointCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WaypointCommand_Mode Mode;
  static const Mode QUERY =
    WaypointCommand_Mode_QUERY;
  static const Mode COMMAND =
    WaypointCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return WaypointCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    WaypointCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    WaypointCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    WaypointCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return WaypointCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return WaypointCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return WaypointCommand_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 5 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 5;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated double latitude = 6 [(.dccl.field) = {
  int latitude_size() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  double latitude(int index) const;
  void set_latitude(int index, double value);
  void add_latitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      latitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_latitude();

  // repeated double longitude = 7 [(.dccl.field) = {
  int longitude_size() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 7;
  double longitude(int index) const;
  void set_longitude(int index, double value);
  void add_longitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      longitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_longitude();

  // repeated float z = 8 [(.dccl.field) = {
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .WaypointCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::WaypointCommand_Mode mode() const;
  void set_mode(::WaypointCommand_Mode value);

  // optional bool end = 9 [(.dccl.field) = {
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 9;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:WaypointCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< double > latitude_;
  ::google::protobuf::RepeatedField< double > longitude_;
  ::google::protobuf::RepeatedField< float > z_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  bool end_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointResponse) */ {
 public:
  MultiWaypointResponse();
  virtual ~MultiWaypointResponse();

  MultiWaypointResponse(const MultiWaypointResponse& from);

  inline MultiWaypointResponse& operator=(const MultiWaypointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointResponse(MultiWaypointResponse&& from) noexcept
    : MultiWaypointResponse() {
    *this = ::std::move(from);
  }

  inline MultiWaypointResponse& operator=(MultiWaypointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointResponse* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointResponse*>(
               &_MultiWaypointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MultiWaypointResponse* other);
  friend void swap(MultiWaypointResponse& a, MultiWaypointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointResponse* New() const final {
    return CreateMaybeMessage<MultiWaypointResponse>(NULL);
  }

  MultiWaypointResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointResponse& from);
  void MergeFrom(const MultiWaypointResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 4 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 4;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated double latitude = 5 [(.dccl.field) = {
  int latitude_size() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  double latitude(int index) const;
  void set_latitude(int index, double value);
  void add_latitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      latitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_latitude();

  // repeated double longitude = 6 [(.dccl.field) = {
  int longitude_size() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  double longitude(int index) const;
  void set_longitude(int index, double value);
  void add_longitude(double value);
  const ::google::protobuf::RepeatedField< double >&
      longitude() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_longitude();

  // repeated float z = 7 [(.dccl.field) = {
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // required double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // optional bool end = 8;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 8;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointResponse)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< double > latitude_;
  ::google::protobuf::RepeatedField< double > longitude_;
  ::google::protobuf::RepeatedField< float > z_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  bool end_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiWaypointCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiWaypointCommand) */ {
 public:
  MultiWaypointCommand();
  virtual ~MultiWaypointCommand();

  MultiWaypointCommand(const MultiWaypointCommand& from);

  inline MultiWaypointCommand& operator=(const MultiWaypointCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiWaypointCommand(MultiWaypointCommand&& from) noexcept
    : MultiWaypointCommand() {
    *this = ::std::move(from);
  }

  inline MultiWaypointCommand& operator=(MultiWaypointCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiWaypointCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiWaypointCommand* internal_default_instance() {
    return reinterpret_cast<const MultiWaypointCommand*>(
               &_MultiWaypointCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MultiWaypointCommand* other);
  friend void swap(MultiWaypointCommand& a, MultiWaypointCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiWaypointCommand* New() const final {
    return CreateMaybeMessage<MultiWaypointCommand>(NULL);
  }

  MultiWaypointCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiWaypointCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiWaypointCommand& from);
  void MergeFrom(const MultiWaypointCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWaypointCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiWaypointCommand_Mode Mode;
  static const Mode QUERY =
    MultiWaypointCommand_Mode_QUERY;
  static const Mode COMMAND =
    MultiWaypointCommand_Mode_COMMAND;
  static inline bool Mode_IsValid(int value) {
    return MultiWaypointCommand_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MultiWaypointCommand_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MultiWaypointCommand_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MultiWaypointCommand_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MultiWaypointCommand_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MultiWaypointCommand_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MultiWaypointCommand_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 wpt_num = 5 [(.dccl.field) = {
  int wpt_num_size() const;
  void clear_wpt_num();
  static const int kWptNumFieldNumber = 5;
  ::google::protobuf::int32 wpt_num(int index) const;
  void set_wpt_num(int index, ::google::protobuf::int32 value);
  void add_wpt_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wpt_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wpt_num();

  // repeated float x = 6 [(.dccl.field) = {
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 6;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 7 [(.dccl.field) = {
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 7;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // repeated float z = 8 [(.dccl.field) = {
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 8;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .MultiWaypointCommand.Mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::MultiWaypointCommand_Mode mode() const;
  void set_mode(::MultiWaypointCommand_Mode value);

  // optional bool end = 9 [(.dccl.field) = {
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 9;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:MultiWaypointCommand)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wpt_num_;
  ::google::protobuf::RepeatedField< float > x_;
  ::google::protobuf::RepeatedField< float > y_;
  ::google::protobuf::RepeatedField< float > z_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  bool end_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteWaypoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExecuteWaypoints) */ {
 public:
  ExecuteWaypoints();
  virtual ~ExecuteWaypoints();

  ExecuteWaypoints(const ExecuteWaypoints& from);

  inline ExecuteWaypoints& operator=(const ExecuteWaypoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteWaypoints(ExecuteWaypoints&& from) noexcept
    : ExecuteWaypoints() {
    *this = ::std::move(from);
  }

  inline ExecuteWaypoints& operator=(ExecuteWaypoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteWaypoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteWaypoints* internal_default_instance() {
    return reinterpret_cast<const ExecuteWaypoints*>(
               &_ExecuteWaypoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ExecuteWaypoints* other);
  friend void swap(ExecuteWaypoints& a, ExecuteWaypoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteWaypoints* New() const final {
    return CreateMaybeMessage<ExecuteWaypoints>(NULL);
  }

  ExecuteWaypoints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteWaypoints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteWaypoints& from);
  void MergeFrom(const ExecuteWaypoints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteWaypoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteWaypoints_ExecuteMode ExecuteMode;
  static const ExecuteMode APPEND =
    ExecuteWaypoints_ExecuteMode_APPEND;
  static const ExecuteMode UPDATE =
    ExecuteWaypoints_ExecuteMode_UPDATE;
  static inline bool ExecuteMode_IsValid(int value) {
    return ExecuteWaypoints_ExecuteMode_IsValid(value);
  }
  static const ExecuteMode ExecuteMode_MIN =
    ExecuteWaypoints_ExecuteMode_ExecuteMode_MIN;
  static const ExecuteMode ExecuteMode_MAX =
    ExecuteWaypoints_ExecuteMode_ExecuteMode_MAX;
  static const int ExecuteMode_ARRAYSIZE =
    ExecuteWaypoints_ExecuteMode_ExecuteMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExecuteMode_descriptor() {
    return ExecuteWaypoints_ExecuteMode_descriptor();
  }
  static inline const ::std::string& ExecuteMode_Name(ExecuteMode value) {
    return ExecuteWaypoints_ExecuteMode_Name(value);
  }
  static inline bool ExecuteMode_Parse(const ::std::string& name,
      ExecuteMode* value) {
    return ExecuteWaypoints_ExecuteMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 source = 1 [(.dccl.field) = {
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required int32 destination = 2 [(.dccl.field) = {
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  ::google::protobuf::int32 destination() const;
  void set_destination(::google::protobuf::int32 value);

  // optional double time = 3 [(.dccl.field) = {
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  double time() const;
  void set_time(double value);

  // required .ExecuteWaypoints.ExecuteMode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::ExecuteWaypoints_ExecuteMode mode() const;
  void set_mode(::ExecuteWaypoints_ExecuteMode value);

  // @@protoc_insertion_point(class_scope:ExecuteWaypoints)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_destination();
  void clear_has_destination();
  void set_has_time();
  void clear_has_time();
  void set_has_mode();
  void clear_has_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 destination_;
  double time_;
  int mode_;
  friend struct ::protobuf_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PoseCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool PoseCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PoseCommand::source() const {
  // @@protoc_insertion_point(field_get:PoseCommand.source)
  return source_;
}
inline void PoseCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PoseCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PoseCommand::destination() const {
  // @@protoc_insertion_point(field_get:PoseCommand.destination)
  return destination_;
}
inline void PoseCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool PoseCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoseCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoseCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoseCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PoseCommand::time() const {
  // @@protoc_insertion_point(field_get:PoseCommand.time)
  return time_;
}
inline void PoseCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PoseCommand.time)
}

// -------------------------------------------------------------------

// PoseResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool PoseResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PoseResponse::source() const {
  // @@protoc_insertion_point(field_get:PoseResponse.source)
  return source_;
}
inline void PoseResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PoseResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PoseResponse::destination() const {
  // @@protoc_insertion_point(field_get:PoseResponse.destination)
  return destination_;
}
inline void PoseResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.destination)
}

// required double time = 3 [(.dccl.field) = {
inline bool PoseResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoseResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoseResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoseResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PoseResponse::time() const {
  // @@protoc_insertion_point(field_get:PoseResponse.time)
  return time_;
}
inline void PoseResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.time)
}

// required double latitude = 4 [(.dccl.field) = {
inline bool PoseResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoseResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoseResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoseResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double PoseResponse::latitude() const {
  // @@protoc_insertion_point(field_get:PoseResponse.latitude)
  return latitude_;
}
inline void PoseResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.latitude)
}

// required double longitude = 5 [(.dccl.field) = {
inline bool PoseResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoseResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoseResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoseResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double PoseResponse::longitude() const {
  // @@protoc_insertion_point(field_get:PoseResponse.longitude)
  return longitude_;
}
inline void PoseResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.longitude)
}

// required float altitude = 6 [(.dccl.field) = {
inline bool PoseResponse::has_altitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PoseResponse::set_has_altitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PoseResponse::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PoseResponse::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float PoseResponse::altitude() const {
  // @@protoc_insertion_point(field_get:PoseResponse.altitude)
  return altitude_;
}
inline void PoseResponse::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.altitude)
}

// required float quat_x = 7 [(.dccl.field) = {
inline bool PoseResponse::has_quat_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PoseResponse::set_has_quat_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PoseResponse::clear_has_quat_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PoseResponse::clear_quat_x() {
  quat_x_ = 0;
  clear_has_quat_x();
}
inline float PoseResponse::quat_x() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_x)
  return quat_x_;
}
inline void PoseResponse::set_quat_x(float value) {
  set_has_quat_x();
  quat_x_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_x)
}

// required float quat_y = 8 [(.dccl.field) = {
inline bool PoseResponse::has_quat_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PoseResponse::set_has_quat_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PoseResponse::clear_has_quat_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PoseResponse::clear_quat_y() {
  quat_y_ = 0;
  clear_has_quat_y();
}
inline float PoseResponse::quat_y() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_y)
  return quat_y_;
}
inline void PoseResponse::set_quat_y(float value) {
  set_has_quat_y();
  quat_y_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_y)
}

// required float quat_z = 9 [(.dccl.field) = {
inline bool PoseResponse::has_quat_z() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PoseResponse::set_has_quat_z() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PoseResponse::clear_has_quat_z() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PoseResponse::clear_quat_z() {
  quat_z_ = 0;
  clear_has_quat_z();
}
inline float PoseResponse::quat_z() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_z)
  return quat_z_;
}
inline void PoseResponse::set_quat_z(float value) {
  set_has_quat_z();
  quat_z_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_z)
}

// required float quat_w = 10 [(.dccl.field) = {
inline bool PoseResponse::has_quat_w() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PoseResponse::set_has_quat_w() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PoseResponse::clear_has_quat_w() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PoseResponse::clear_quat_w() {
  quat_w_ = 0;
  clear_has_quat_w();
}
inline float PoseResponse::quat_w() const {
  // @@protoc_insertion_point(field_get:PoseResponse.quat_w)
  return quat_w_;
}
inline void PoseResponse::set_quat_w(float value) {
  set_has_quat_w();
  quat_w_ = value;
  // @@protoc_insertion_point(field_set:PoseResponse.quat_w)
}

// -------------------------------------------------------------------

// PowerCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool PowerCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PowerCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PowerCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PowerCommand::source() const {
  // @@protoc_insertion_point(field_get:PowerCommand.source)
  return source_;
}
inline void PowerCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PowerCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PowerCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PowerCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PowerCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PowerCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PowerCommand::destination() const {
  // @@protoc_insertion_point(field_get:PowerCommand.destination)
  return destination_;
}
inline void PowerCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PowerCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool PowerCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PowerCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PowerCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PowerCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PowerCommand::time() const {
  // @@protoc_insertion_point(field_get:PowerCommand.time)
  return time_;
}
inline void PowerCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PowerCommand.time)
}

// -------------------------------------------------------------------

// PowerResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool PowerResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PowerResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PowerResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 PowerResponse::source() const {
  // @@protoc_insertion_point(field_get:PowerResponse.source)
  return source_;
}
inline void PowerResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:PowerResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool PowerResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PowerResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PowerResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PowerResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 PowerResponse::destination() const {
  // @@protoc_insertion_point(field_get:PowerResponse.destination)
  return destination_;
}
inline void PowerResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:PowerResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool PowerResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PowerResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PowerResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PowerResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PowerResponse::time() const {
  // @@protoc_insertion_point(field_get:PowerResponse.time)
  return time_;
}
inline void PowerResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:PowerResponse.time)
}

// required float battery_voltage = 4 [(.dccl.field) = {
inline bool PowerResponse::has_battery_voltage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PowerResponse::set_has_battery_voltage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PowerResponse::clear_has_battery_voltage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PowerResponse::clear_battery_voltage() {
  battery_voltage_ = 0;
  clear_has_battery_voltage();
}
inline float PowerResponse::battery_voltage() const {
  // @@protoc_insertion_point(field_get:PowerResponse.battery_voltage)
  return battery_voltage_;
}
inline void PowerResponse::set_battery_voltage(float value) {
  set_has_battery_voltage();
  battery_voltage_ = value;
  // @@protoc_insertion_point(field_set:PowerResponse.battery_voltage)
}

// required float current = 5 [(.dccl.field) = {
inline bool PowerResponse::has_current() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PowerResponse::set_has_current() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PowerResponse::clear_has_current() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PowerResponse::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float PowerResponse::current() const {
  // @@protoc_insertion_point(field_get:PowerResponse.current)
  return current_;
}
inline void PowerResponse::set_current(float value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:PowerResponse.current)
}

// -------------------------------------------------------------------

// RelativePoseCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool RelativePoseCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePoseCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePoseCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePoseCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 RelativePoseCommand::source() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.source)
  return source_;
}
inline void RelativePoseCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool RelativePoseCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePoseCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePoseCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePoseCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 RelativePoseCommand::destination() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.destination)
  return destination_;
}
inline void RelativePoseCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool RelativePoseCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePoseCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePoseCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePoseCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double RelativePoseCommand::time() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.time)
  return time_;
}
inline void RelativePoseCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.time)
}

// required .RelativePoseCommand.Frame parent = 4;
inline bool RelativePoseCommand::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePoseCommand::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePoseCommand::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePoseCommand::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::RelativePoseCommand_Frame RelativePoseCommand::parent() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.parent)
  return static_cast< ::RelativePoseCommand_Frame >(parent_);
}
inline void RelativePoseCommand::set_parent(::RelativePoseCommand_Frame value) {
  assert(::RelativePoseCommand_Frame_IsValid(value));
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.parent)
}

// required .RelativePoseCommand.Frame child = 5;
inline bool RelativePoseCommand::has_child() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePoseCommand::set_has_child() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePoseCommand::clear_has_child() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePoseCommand::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::RelativePoseCommand_Frame RelativePoseCommand::child() const {
  // @@protoc_insertion_point(field_get:RelativePoseCommand.child)
  return static_cast< ::RelativePoseCommand_Frame >(child_);
}
inline void RelativePoseCommand::set_child(::RelativePoseCommand_Frame value) {
  assert(::RelativePoseCommand_Frame_IsValid(value));
  set_has_child();
  child_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseCommand.child)
}

// -------------------------------------------------------------------

// RelativePoseResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool RelativePoseResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePoseResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePoseResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePoseResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 RelativePoseResponse::source() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.source)
  return source_;
}
inline void RelativePoseResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool RelativePoseResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePoseResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePoseResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePoseResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 RelativePoseResponse::destination() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.destination)
  return destination_;
}
inline void RelativePoseResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool RelativePoseResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePoseResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePoseResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePoseResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double RelativePoseResponse::time() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.time)
  return time_;
}
inline void RelativePoseResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.time)
}

// required .RelativePoseResponse.Frame parent = 4;
inline bool RelativePoseResponse::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePoseResponse::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePoseResponse::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePoseResponse::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::RelativePoseResponse_Frame RelativePoseResponse::parent() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.parent)
  return static_cast< ::RelativePoseResponse_Frame >(parent_);
}
inline void RelativePoseResponse::set_parent(::RelativePoseResponse_Frame value) {
  assert(::RelativePoseResponse_Frame_IsValid(value));
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.parent)
}

// required .RelativePoseResponse.Frame child = 5;
inline bool RelativePoseResponse::has_child() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePoseResponse::set_has_child() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePoseResponse::clear_has_child() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePoseResponse::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::RelativePoseResponse_Frame RelativePoseResponse::child() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.child)
  return static_cast< ::RelativePoseResponse_Frame >(child_);
}
inline void RelativePoseResponse::set_child(::RelativePoseResponse_Frame value) {
  assert(::RelativePoseResponse_Frame_IsValid(value));
  set_has_child();
  child_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.child)
}

// required double latitude = 6 [(.dccl.field) = {
inline bool RelativePoseResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RelativePoseResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RelativePoseResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RelativePoseResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double RelativePoseResponse::latitude() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.latitude)
  return latitude_;
}
inline void RelativePoseResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.latitude)
}

// required double longitude = 7 [(.dccl.field) = {
inline bool RelativePoseResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RelativePoseResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RelativePoseResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RelativePoseResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double RelativePoseResponse::longitude() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.longitude)
  return longitude_;
}
inline void RelativePoseResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.longitude)
}

// required float x = 8 [(.dccl.field) = {
inline bool RelativePoseResponse::has_x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RelativePoseResponse::set_has_x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RelativePoseResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RelativePoseResponse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float RelativePoseResponse::x() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.x)
  return x_;
}
inline void RelativePoseResponse::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.x)
}

// required float y = 9 [(.dccl.field) = {
inline bool RelativePoseResponse::has_y() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RelativePoseResponse::set_has_y() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RelativePoseResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RelativePoseResponse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float RelativePoseResponse::y() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.y)
  return y_;
}
inline void RelativePoseResponse::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.y)
}

// required float z = 10 [(.dccl.field) = {
inline bool RelativePoseResponse::has_z() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RelativePoseResponse::set_has_z() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RelativePoseResponse::clear_has_z() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RelativePoseResponse::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float RelativePoseResponse::z() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.z)
  return z_;
}
inline void RelativePoseResponse::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.z)
}

// required float quat_x = 11 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RelativePoseResponse::set_has_quat_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RelativePoseResponse::clear_has_quat_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RelativePoseResponse::clear_quat_x() {
  quat_x_ = 0;
  clear_has_quat_x();
}
inline float RelativePoseResponse::quat_x() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_x)
  return quat_x_;
}
inline void RelativePoseResponse::set_quat_x(float value) {
  set_has_quat_x();
  quat_x_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_x)
}

// required float quat_y = 12 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RelativePoseResponse::set_has_quat_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RelativePoseResponse::clear_has_quat_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RelativePoseResponse::clear_quat_y() {
  quat_y_ = 0;
  clear_has_quat_y();
}
inline float RelativePoseResponse::quat_y() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_y)
  return quat_y_;
}
inline void RelativePoseResponse::set_quat_y(float value) {
  set_has_quat_y();
  quat_y_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_y)
}

// required float quat_z = 13 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_z() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RelativePoseResponse::set_has_quat_z() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RelativePoseResponse::clear_has_quat_z() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RelativePoseResponse::clear_quat_z() {
  quat_z_ = 0;
  clear_has_quat_z();
}
inline float RelativePoseResponse::quat_z() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_z)
  return quat_z_;
}
inline void RelativePoseResponse::set_quat_z(float value) {
  set_has_quat_z();
  quat_z_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_z)
}

// required float quat_w = 14 [(.dccl.field) = {
inline bool RelativePoseResponse::has_quat_w() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RelativePoseResponse::set_has_quat_w() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RelativePoseResponse::clear_has_quat_w() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RelativePoseResponse::clear_quat_w() {
  quat_w_ = 0;
  clear_has_quat_w();
}
inline float RelativePoseResponse::quat_w() const {
  // @@protoc_insertion_point(field_get:RelativePoseResponse.quat_w)
  return quat_w_;
}
inline void RelativePoseResponse::set_quat_w(float value) {
  set_has_quat_w();
  quat_w_ = value;
  // @@protoc_insertion_point(field_set:RelativePoseResponse.quat_w)
}

// -------------------------------------------------------------------

// ControllerStateCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool ControllerStateCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerStateCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerStateCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerStateCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ControllerStateCommand::source() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.source)
  return source_;
}
inline void ControllerStateCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ControllerStateCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerStateCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerStateCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerStateCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ControllerStateCommand::destination() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.destination)
  return destination_;
}
inline void ControllerStateCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ControllerStateCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerStateCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerStateCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerStateCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ControllerStateCommand::time() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.time)
  return time_;
}
inline void ControllerStateCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.time)
}

// required .ControllerStateCommand.Mode mode = 4;
inline bool ControllerStateCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerStateCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerStateCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerStateCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ControllerStateCommand_Mode ControllerStateCommand::mode() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.mode)
  return static_cast< ::ControllerStateCommand_Mode >(mode_);
}
inline void ControllerStateCommand::set_mode(::ControllerStateCommand_Mode value) {
  assert(::ControllerStateCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.mode)
}

// optional .ControllerStateCommand.ControllerState state = 5 [(.dccl.field) = {
inline bool ControllerStateCommand::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControllerStateCommand::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControllerStateCommand::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControllerStateCommand::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::ControllerStateCommand_ControllerState ControllerStateCommand::state() const {
  // @@protoc_insertion_point(field_get:ControllerStateCommand.state)
  return static_cast< ::ControllerStateCommand_ControllerState >(state_);
}
inline void ControllerStateCommand::set_state(::ControllerStateCommand_ControllerState value) {
  assert(::ControllerStateCommand_ControllerState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateCommand.state)
}

// -------------------------------------------------------------------

// ControllerStateResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool ControllerStateResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerStateResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerStateResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerStateResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ControllerStateResponse::source() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.source)
  return source_;
}
inline void ControllerStateResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ControllerStateResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerStateResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerStateResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerStateResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ControllerStateResponse::destination() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.destination)
  return destination_;
}
inline void ControllerStateResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ControllerStateResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerStateResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerStateResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerStateResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ControllerStateResponse::time() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.time)
  return time_;
}
inline void ControllerStateResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.time)
}

// optional .ControllerStateResponse.ControllerState state = 4;
inline bool ControllerStateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerStateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerStateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerStateResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::ControllerStateResponse_ControllerState ControllerStateResponse::state() const {
  // @@protoc_insertion_point(field_get:ControllerStateResponse.state)
  return static_cast< ::ControllerStateResponse_ControllerState >(state_);
}
inline void ControllerStateResponse::set_state(::ControllerStateResponse_ControllerState value) {
  assert(::ControllerStateResponse_ControllerState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ControllerStateResponse.state)
}

// -------------------------------------------------------------------

// DirectControlCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool DirectControlCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectControlCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectControlCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectControlCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 DirectControlCommand::source() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.source)
  return source_;
}
inline void DirectControlCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool DirectControlCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectControlCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectControlCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectControlCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 DirectControlCommand::destination() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.destination)
  return destination_;
}
inline void DirectControlCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool DirectControlCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectControlCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectControlCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectControlCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double DirectControlCommand::time() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.time)
  return time_;
}
inline void DirectControlCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.time)
}

// required .DirectControlCommand.Frame frame = 4;
inline bool DirectControlCommand::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectControlCommand::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectControlCommand::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectControlCommand::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::DirectControlCommand_Frame DirectControlCommand::frame() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.frame)
  return static_cast< ::DirectControlCommand_Frame >(frame_);
}
inline void DirectControlCommand::set_frame(::DirectControlCommand_Frame value) {
  assert(::DirectControlCommand_Frame_IsValid(value));
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.frame)
}

// required float x = 5 [(.dccl.field) = {
inline bool DirectControlCommand::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectControlCommand::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectControlCommand::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectControlCommand::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float DirectControlCommand::x() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.x)
  return x_;
}
inline void DirectControlCommand::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.x)
}

// required float y = 6 [(.dccl.field) = {
inline bool DirectControlCommand::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectControlCommand::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectControlCommand::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectControlCommand::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float DirectControlCommand::y() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.y)
  return y_;
}
inline void DirectControlCommand::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.y)
}

// required float z = 7 [(.dccl.field) = {
inline bool DirectControlCommand::has_z() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectControlCommand::set_has_z() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectControlCommand::clear_has_z() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectControlCommand::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float DirectControlCommand::z() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.z)
  return z_;
}
inline void DirectControlCommand::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.z)
}

// required float roll = 8 [(.dccl.field) = {
inline bool DirectControlCommand::has_roll() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectControlCommand::set_has_roll() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectControlCommand::clear_has_roll() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectControlCommand::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float DirectControlCommand::roll() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.roll)
  return roll_;
}
inline void DirectControlCommand::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.roll)
}

// required float pitch = 9 [(.dccl.field) = {
inline bool DirectControlCommand::has_pitch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectControlCommand::set_has_pitch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectControlCommand::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectControlCommand::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float DirectControlCommand::pitch() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.pitch)
  return pitch_;
}
inline void DirectControlCommand::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.pitch)
}

// required float yaw = 10 [(.dccl.field) = {
inline bool DirectControlCommand::has_yaw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectControlCommand::set_has_yaw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectControlCommand::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectControlCommand::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float DirectControlCommand::yaw() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.yaw)
  return yaw_;
}
inline void DirectControlCommand::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.yaw)
}

// required float u = 11 [(.dccl.field) = {
inline bool DirectControlCommand::has_u() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DirectControlCommand::set_has_u() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DirectControlCommand::clear_has_u() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DirectControlCommand::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline float DirectControlCommand::u() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.u)
  return u_;
}
inline void DirectControlCommand::set_u(float value) {
  set_has_u();
  u_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.u)
}

// required float v = 12 [(.dccl.field) = {
inline bool DirectControlCommand::has_v() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DirectControlCommand::set_has_v() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DirectControlCommand::clear_has_v() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DirectControlCommand::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline float DirectControlCommand::v() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.v)
  return v_;
}
inline void DirectControlCommand::set_v(float value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.v)
}

// required float w = 13 [(.dccl.field) = {
inline bool DirectControlCommand::has_w() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DirectControlCommand::set_has_w() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DirectControlCommand::clear_has_w() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DirectControlCommand::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float DirectControlCommand::w() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.w)
  return w_;
}
inline void DirectControlCommand::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.w)
}

// required float p = 14 [(.dccl.field) = {
inline bool DirectControlCommand::has_p() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DirectControlCommand::set_has_p() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DirectControlCommand::clear_has_p() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DirectControlCommand::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float DirectControlCommand::p() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.p)
  return p_;
}
inline void DirectControlCommand::set_p(float value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.p)
}

// required float q = 15 [(.dccl.field) = {
inline bool DirectControlCommand::has_q() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DirectControlCommand::set_has_q() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DirectControlCommand::clear_has_q() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DirectControlCommand::clear_q() {
  q_ = 0;
  clear_has_q();
}
inline float DirectControlCommand::q() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.q)
  return q_;
}
inline void DirectControlCommand::set_q(float value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.q)
}

// required float r = 16 [(.dccl.field) = {
inline bool DirectControlCommand::has_r() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DirectControlCommand::set_has_r() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DirectControlCommand::clear_has_r() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DirectControlCommand::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float DirectControlCommand::r() const {
  // @@protoc_insertion_point(field_get:DirectControlCommand.r)
  return r_;
}
inline void DirectControlCommand::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:DirectControlCommand.r)
}

// -------------------------------------------------------------------

// HelmStateCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool HelmStateCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelmStateCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelmStateCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelmStateCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 HelmStateCommand::source() const {
  // @@protoc_insertion_point(field_get:HelmStateCommand.source)
  return source_;
}
inline void HelmStateCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:HelmStateCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool HelmStateCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelmStateCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelmStateCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelmStateCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 HelmStateCommand::destination() const {
  // @@protoc_insertion_point(field_get:HelmStateCommand.destination)
  return destination_;
}
inline void HelmStateCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:HelmStateCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool HelmStateCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HelmStateCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HelmStateCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HelmStateCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double HelmStateCommand::time() const {
  // @@protoc_insertion_point(field_get:HelmStateCommand.time)
  return time_;
}
inline void HelmStateCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:HelmStateCommand.time)
}

// required .HelmStateCommand.Mode mode = 4;
inline bool HelmStateCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HelmStateCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HelmStateCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HelmStateCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::HelmStateCommand_Mode HelmStateCommand::mode() const {
  // @@protoc_insertion_point(field_get:HelmStateCommand.mode)
  return static_cast< ::HelmStateCommand_Mode >(mode_);
}
inline void HelmStateCommand::set_mode(::HelmStateCommand_Mode value) {
  assert(::HelmStateCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:HelmStateCommand.mode)
}

// optional .HelmStateCommand.HelmState state = 5 [(.dccl.field) = {
inline bool HelmStateCommand::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HelmStateCommand::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HelmStateCommand::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HelmStateCommand::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::HelmStateCommand_HelmState HelmStateCommand::state() const {
  // @@protoc_insertion_point(field_get:HelmStateCommand.state)
  return static_cast< ::HelmStateCommand_HelmState >(state_);
}
inline void HelmStateCommand::set_state(::HelmStateCommand_HelmState value) {
  assert(::HelmStateCommand_HelmState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:HelmStateCommand.state)
}

// -------------------------------------------------------------------

// HelmStateResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool HelmStateResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelmStateResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelmStateResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelmStateResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 HelmStateResponse::source() const {
  // @@protoc_insertion_point(field_get:HelmStateResponse.source)
  return source_;
}
inline void HelmStateResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:HelmStateResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool HelmStateResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelmStateResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelmStateResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelmStateResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 HelmStateResponse::destination() const {
  // @@protoc_insertion_point(field_get:HelmStateResponse.destination)
  return destination_;
}
inline void HelmStateResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:HelmStateResponse.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool HelmStateResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HelmStateResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HelmStateResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HelmStateResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double HelmStateResponse::time() const {
  // @@protoc_insertion_point(field_get:HelmStateResponse.time)
  return time_;
}
inline void HelmStateResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:HelmStateResponse.time)
}

// required .HelmStateResponse.HelmState helm_state = 4;
inline bool HelmStateResponse::has_helm_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HelmStateResponse::set_has_helm_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HelmStateResponse::clear_has_helm_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HelmStateResponse::clear_helm_state() {
  helm_state_ = 0;
  clear_has_helm_state();
}
inline ::HelmStateResponse_HelmState HelmStateResponse::helm_state() const {
  // @@protoc_insertion_point(field_get:HelmStateResponse.helm_state)
  return static_cast< ::HelmStateResponse_HelmState >(helm_state_);
}
inline void HelmStateResponse::set_helm_state(::HelmStateResponse_HelmState value) {
  assert(::HelmStateResponse_HelmState_IsValid(value));
  set_has_helm_state();
  helm_state_ = value;
  // @@protoc_insertion_point(field_set:HelmStateResponse.helm_state)
}

// -------------------------------------------------------------------

// WaypointCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool WaypointCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaypointCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaypointCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaypointCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 WaypointCommand::source() const {
  // @@protoc_insertion_point(field_get:WaypointCommand.source)
  return source_;
}
inline void WaypointCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:WaypointCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool WaypointCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WaypointCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WaypointCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WaypointCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 WaypointCommand::destination() const {
  // @@protoc_insertion_point(field_get:WaypointCommand.destination)
  return destination_;
}
inline void WaypointCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:WaypointCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool WaypointCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WaypointCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WaypointCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WaypointCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double WaypointCommand::time() const {
  // @@protoc_insertion_point(field_get:WaypointCommand.time)
  return time_;
}
inline void WaypointCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:WaypointCommand.time)
}

// required .WaypointCommand.Mode mode = 4;
inline bool WaypointCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WaypointCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WaypointCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WaypointCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::WaypointCommand_Mode WaypointCommand::mode() const {
  // @@protoc_insertion_point(field_get:WaypointCommand.mode)
  return static_cast< ::WaypointCommand_Mode >(mode_);
}
inline void WaypointCommand::set_mode(::WaypointCommand_Mode value) {
  assert(::WaypointCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:WaypointCommand.mode)
}

// repeated int32 wpt_num = 5 [(.dccl.field) = {
inline int WaypointCommand::wpt_num_size() const {
  return wpt_num_.size();
}
inline void WaypointCommand::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 WaypointCommand::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:WaypointCommand.wpt_num)
  return wpt_num_.Get(index);
}
inline void WaypointCommand::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:WaypointCommand.wpt_num)
}
inline void WaypointCommand::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:WaypointCommand.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
WaypointCommand::wpt_num() const {
  // @@protoc_insertion_point(field_list:WaypointCommand.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
WaypointCommand::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:WaypointCommand.wpt_num)
  return &wpt_num_;
}

// repeated double latitude = 6 [(.dccl.field) = {
inline int WaypointCommand::latitude_size() const {
  return latitude_.size();
}
inline void WaypointCommand::clear_latitude() {
  latitude_.Clear();
}
inline double WaypointCommand::latitude(int index) const {
  // @@protoc_insertion_point(field_get:WaypointCommand.latitude)
  return latitude_.Get(index);
}
inline void WaypointCommand::set_latitude(int index, double value) {
  latitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:WaypointCommand.latitude)
}
inline void WaypointCommand::add_latitude(double value) {
  latitude_.Add(value);
  // @@protoc_insertion_point(field_add:WaypointCommand.latitude)
}
inline const ::google::protobuf::RepeatedField< double >&
WaypointCommand::latitude() const {
  // @@protoc_insertion_point(field_list:WaypointCommand.latitude)
  return latitude_;
}
inline ::google::protobuf::RepeatedField< double >*
WaypointCommand::mutable_latitude() {
  // @@protoc_insertion_point(field_mutable_list:WaypointCommand.latitude)
  return &latitude_;
}

// repeated double longitude = 7 [(.dccl.field) = {
inline int WaypointCommand::longitude_size() const {
  return longitude_.size();
}
inline void WaypointCommand::clear_longitude() {
  longitude_.Clear();
}
inline double WaypointCommand::longitude(int index) const {
  // @@protoc_insertion_point(field_get:WaypointCommand.longitude)
  return longitude_.Get(index);
}
inline void WaypointCommand::set_longitude(int index, double value) {
  longitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:WaypointCommand.longitude)
}
inline void WaypointCommand::add_longitude(double value) {
  longitude_.Add(value);
  // @@protoc_insertion_point(field_add:WaypointCommand.longitude)
}
inline const ::google::protobuf::RepeatedField< double >&
WaypointCommand::longitude() const {
  // @@protoc_insertion_point(field_list:WaypointCommand.longitude)
  return longitude_;
}
inline ::google::protobuf::RepeatedField< double >*
WaypointCommand::mutable_longitude() {
  // @@protoc_insertion_point(field_mutable_list:WaypointCommand.longitude)
  return &longitude_;
}

// repeated float z = 8 [(.dccl.field) = {
inline int WaypointCommand::z_size() const {
  return z_.size();
}
inline void WaypointCommand::clear_z() {
  z_.Clear();
}
inline float WaypointCommand::z(int index) const {
  // @@protoc_insertion_point(field_get:WaypointCommand.z)
  return z_.Get(index);
}
inline void WaypointCommand::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:WaypointCommand.z)
}
inline void WaypointCommand::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:WaypointCommand.z)
}
inline const ::google::protobuf::RepeatedField< float >&
WaypointCommand::z() const {
  // @@protoc_insertion_point(field_list:WaypointCommand.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
WaypointCommand::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:WaypointCommand.z)
  return &z_;
}

// optional bool end = 9 [(.dccl.field) = {
inline bool WaypointCommand::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WaypointCommand::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WaypointCommand::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WaypointCommand::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool WaypointCommand::end() const {
  // @@protoc_insertion_point(field_get:WaypointCommand.end)
  return end_;
}
inline void WaypointCommand::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:WaypointCommand.end)
}

// -------------------------------------------------------------------

// MultiWaypointResponse

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointResponse::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointResponse::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointResponse::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointResponse::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.source)
  return source_;
}
inline void MultiWaypointResponse::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointResponse::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointResponse::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointResponse::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointResponse::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointResponse::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.destination)
  return destination_;
}
inline void MultiWaypointResponse::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.destination)
}

// required double time = 3 [(.dccl.field) = {
inline bool MultiWaypointResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointResponse::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointResponse::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.time)
  return time_;
}
inline void MultiWaypointResponse::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.time)
}

// repeated int32 wpt_num = 4 [(.dccl.field) = {
inline int MultiWaypointResponse::wpt_num_size() const {
  return wpt_num_.size();
}
inline void MultiWaypointResponse::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 MultiWaypointResponse::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.wpt_num)
  return wpt_num_.Get(index);
}
inline void MultiWaypointResponse::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.wpt_num)
}
inline void MultiWaypointResponse::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointResponse.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiWaypointResponse::wpt_num() const {
  // @@protoc_insertion_point(field_list:MultiWaypointResponse.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiWaypointResponse::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointResponse.wpt_num)
  return &wpt_num_;
}

// repeated double latitude = 5 [(.dccl.field) = {
inline int MultiWaypointResponse::latitude_size() const {
  return latitude_.size();
}
inline void MultiWaypointResponse::clear_latitude() {
  latitude_.Clear();
}
inline double MultiWaypointResponse::latitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.latitude)
  return latitude_.Get(index);
}
inline void MultiWaypointResponse::set_latitude(int index, double value) {
  latitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.latitude)
}
inline void MultiWaypointResponse::add_latitude(double value) {
  latitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointResponse.latitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointResponse::latitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointResponse.latitude)
  return latitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointResponse::mutable_latitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointResponse.latitude)
  return &latitude_;
}

// repeated double longitude = 6 [(.dccl.field) = {
inline int MultiWaypointResponse::longitude_size() const {
  return longitude_.size();
}
inline void MultiWaypointResponse::clear_longitude() {
  longitude_.Clear();
}
inline double MultiWaypointResponse::longitude(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.longitude)
  return longitude_.Get(index);
}
inline void MultiWaypointResponse::set_longitude(int index, double value) {
  longitude_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.longitude)
}
inline void MultiWaypointResponse::add_longitude(double value) {
  longitude_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointResponse.longitude)
}
inline const ::google::protobuf::RepeatedField< double >&
MultiWaypointResponse::longitude() const {
  // @@protoc_insertion_point(field_list:MultiWaypointResponse.longitude)
  return longitude_;
}
inline ::google::protobuf::RepeatedField< double >*
MultiWaypointResponse::mutable_longitude() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointResponse.longitude)
  return &longitude_;
}

// repeated float z = 7 [(.dccl.field) = {
inline int MultiWaypointResponse::z_size() const {
  return z_.size();
}
inline void MultiWaypointResponse::clear_z() {
  z_.Clear();
}
inline float MultiWaypointResponse::z(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.z)
  return z_.Get(index);
}
inline void MultiWaypointResponse::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.z)
}
inline void MultiWaypointResponse::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointResponse.z)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointResponse::z() const {
  // @@protoc_insertion_point(field_list:MultiWaypointResponse.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointResponse::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointResponse.z)
  return &z_;
}

// optional bool end = 8;
inline bool MultiWaypointResponse::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointResponse::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointResponse::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointResponse::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointResponse::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointResponse.end)
  return end_;
}
inline void MultiWaypointResponse::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointResponse.end)
}

// -------------------------------------------------------------------

// MultiWaypointCommand

// required int32 source = 1 [(.dccl.field) = {
inline bool MultiWaypointCommand::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiWaypointCommand::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiWaypointCommand::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiWaypointCommand::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 MultiWaypointCommand::source() const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.source)
  return source_;
}
inline void MultiWaypointCommand::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool MultiWaypointCommand::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiWaypointCommand::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiWaypointCommand::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiWaypointCommand::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 MultiWaypointCommand::destination() const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.destination)
  return destination_;
}
inline void MultiWaypointCommand::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool MultiWaypointCommand::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiWaypointCommand::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiWaypointCommand::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiWaypointCommand::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MultiWaypointCommand::time() const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.time)
  return time_;
}
inline void MultiWaypointCommand::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.time)
}

// required .MultiWaypointCommand.Mode mode = 4;
inline bool MultiWaypointCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiWaypointCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiWaypointCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiWaypointCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::MultiWaypointCommand_Mode MultiWaypointCommand::mode() const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.mode)
  return static_cast< ::MultiWaypointCommand_Mode >(mode_);
}
inline void MultiWaypointCommand::set_mode(::MultiWaypointCommand_Mode value) {
  assert(::MultiWaypointCommand_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.mode)
}

// repeated int32 wpt_num = 5 [(.dccl.field) = {
inline int MultiWaypointCommand::wpt_num_size() const {
  return wpt_num_.size();
}
inline void MultiWaypointCommand::clear_wpt_num() {
  wpt_num_.Clear();
}
inline ::google::protobuf::int32 MultiWaypointCommand::wpt_num(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.wpt_num)
  return wpt_num_.Get(index);
}
inline void MultiWaypointCommand::set_wpt_num(int index, ::google::protobuf::int32 value) {
  wpt_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.wpt_num)
}
inline void MultiWaypointCommand::add_wpt_num(::google::protobuf::int32 value) {
  wpt_num_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointCommand.wpt_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiWaypointCommand::wpt_num() const {
  // @@protoc_insertion_point(field_list:MultiWaypointCommand.wpt_num)
  return wpt_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiWaypointCommand::mutable_wpt_num() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointCommand.wpt_num)
  return &wpt_num_;
}

// repeated float x = 6 [(.dccl.field) = {
inline int MultiWaypointCommand::x_size() const {
  return x_.size();
}
inline void MultiWaypointCommand::clear_x() {
  x_.Clear();
}
inline float MultiWaypointCommand::x(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.x)
  return x_.Get(index);
}
inline void MultiWaypointCommand::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.x)
}
inline void MultiWaypointCommand::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointCommand.x)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointCommand::x() const {
  // @@protoc_insertion_point(field_list:MultiWaypointCommand.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointCommand::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointCommand.x)
  return &x_;
}

// repeated float y = 7 [(.dccl.field) = {
inline int MultiWaypointCommand::y_size() const {
  return y_.size();
}
inline void MultiWaypointCommand::clear_y() {
  y_.Clear();
}
inline float MultiWaypointCommand::y(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.y)
  return y_.Get(index);
}
inline void MultiWaypointCommand::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.y)
}
inline void MultiWaypointCommand::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointCommand.y)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointCommand::y() const {
  // @@protoc_insertion_point(field_list:MultiWaypointCommand.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointCommand::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointCommand.y)
  return &y_;
}

// repeated float z = 8 [(.dccl.field) = {
inline int MultiWaypointCommand::z_size() const {
  return z_.size();
}
inline void MultiWaypointCommand::clear_z() {
  z_.Clear();
}
inline float MultiWaypointCommand::z(int index) const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.z)
  return z_.Get(index);
}
inline void MultiWaypointCommand::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.z)
}
inline void MultiWaypointCommand::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:MultiWaypointCommand.z)
}
inline const ::google::protobuf::RepeatedField< float >&
MultiWaypointCommand::z() const {
  // @@protoc_insertion_point(field_list:MultiWaypointCommand.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiWaypointCommand::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:MultiWaypointCommand.z)
  return &z_;
}

// optional bool end = 9 [(.dccl.field) = {
inline bool MultiWaypointCommand::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiWaypointCommand::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiWaypointCommand::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiWaypointCommand::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool MultiWaypointCommand::end() const {
  // @@protoc_insertion_point(field_get:MultiWaypointCommand.end)
  return end_;
}
inline void MultiWaypointCommand::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:MultiWaypointCommand.end)
}

// -------------------------------------------------------------------

// ExecuteWaypoints

// required int32 source = 1 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteWaypoints::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteWaypoints::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteWaypoints::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 ExecuteWaypoints::source() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.source)
  return source_;
}
inline void ExecuteWaypoints::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.source)
}

// required int32 destination = 2 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_destination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteWaypoints::set_has_destination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteWaypoints::clear_has_destination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteWaypoints::clear_destination() {
  destination_ = 0;
  clear_has_destination();
}
inline ::google::protobuf::int32 ExecuteWaypoints::destination() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.destination)
  return destination_;
}
inline void ExecuteWaypoints::set_destination(::google::protobuf::int32 value) {
  set_has_destination();
  destination_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.destination)
}

// optional double time = 3 [(.dccl.field) = {
inline bool ExecuteWaypoints::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecuteWaypoints::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecuteWaypoints::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecuteWaypoints::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ExecuteWaypoints::time() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.time)
  return time_;
}
inline void ExecuteWaypoints::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.time)
}

// required .ExecuteWaypoints.ExecuteMode mode = 4;
inline bool ExecuteWaypoints::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecuteWaypoints::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecuteWaypoints::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecuteWaypoints::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ExecuteWaypoints_ExecuteMode ExecuteWaypoints::mode() const {
  // @@protoc_insertion_point(field_get:ExecuteWaypoints.mode)
  return static_cast< ::ExecuteWaypoints_ExecuteMode >(mode_);
}
inline void ExecuteWaypoints::set_mode(::ExecuteWaypoints_ExecuteMode value) {
  assert(::ExecuteWaypoints_ExecuteMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ExecuteWaypoints.mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RelativePoseCommand_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelativePoseCommand_Frame>() {
  return ::RelativePoseCommand_Frame_descriptor();
}
template <> struct is_proto_enum< ::RelativePoseResponse_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelativePoseResponse_Frame>() {
  return ::RelativePoseResponse_Frame_descriptor();
}
template <> struct is_proto_enum< ::ControllerStateCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ControllerStateCommand_Mode>() {
  return ::ControllerStateCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::ControllerStateCommand_ControllerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ControllerStateCommand_ControllerState>() {
  return ::ControllerStateCommand_ControllerState_descriptor();
}
template <> struct is_proto_enum< ::ControllerStateResponse_ControllerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ControllerStateResponse_ControllerState>() {
  return ::ControllerStateResponse_ControllerState_descriptor();
}
template <> struct is_proto_enum< ::DirectControlCommand_Frame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DirectControlCommand_Frame>() {
  return ::DirectControlCommand_Frame_descriptor();
}
template <> struct is_proto_enum< ::HelmStateCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelmStateCommand_Mode>() {
  return ::HelmStateCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::HelmStateCommand_HelmState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelmStateCommand_HelmState>() {
  return ::HelmStateCommand_HelmState_descriptor();
}
template <> struct is_proto_enum< ::HelmStateResponse_HelmState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelmStateResponse_HelmState>() {
  return ::HelmStateResponse_HelmState_descriptor();
}
template <> struct is_proto_enum< ::WaypointCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WaypointCommand_Mode>() {
  return ::WaypointCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::MultiWaypointCommand_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MultiWaypointCommand_Mode>() {
  return ::MultiWaypointCommand_Mode_descriptor();
}
template <> struct is_proto_enum< ::ExecuteWaypoints_ExecuteMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExecuteWaypoints_ExecuteMode>() {
  return ::ExecuteWaypoints_ExecuteMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_alpha_5facomms_2fsrc_2fproto_2fgoby_5fmsgs_2eproto
